'use strict';

function _lazyRequire(moduleId) {
  return new Proxy(
    {},
    {
      get(_target, propertyKey) {
        const importedModule = require(moduleId);
        return Reflect.get(importedModule, propertyKey);
      },
      set(_target, propertyKey, value) {
        const importedModule = require(moduleId);
        return Reflect.set(importedModule, propertyKey, value);
      },
    },
  );
}

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

const path$1 = require('path');
const path$1__default = _interopDefault(path$1);
const index_js = _lazyRequire('../dev-server/index.js');
const stencil_js = require('../compiler/stencil.js');
const ts = _interopDefault(require('typescript'));
const appData = _lazyRequire('@stencil/core/internal/app-data');
const index_js$1 = _lazyRequire('../mock-doc/index.js');
const url$1 = require('url');
const testing = _lazyRequire('@stencil/core/internal/testing');
const fs$1 = _interopDefault(require('fs'));
const crypto$2 = require('crypto');
const child_process$1 = require('child_process');

async function startPuppeteerBrowser(config) {
    if (!config.flags.e2e) {
        return null;
    }
    const env = process.env;
    const puppeteerDep = config.testing.browserExecutablePath ? 'puppeteer-core' : 'puppeteer';
    const puppeteerModulePath = config.sys.lazyRequire.getModulePath(puppeteerDep);
    const puppeteer = require(puppeteerModulePath);
    env.__STENCIL_PUPPETEER_MODULE__ = puppeteerModulePath;
    env.__STENCIL_BROWSER_WAIT_UNTIL = config.testing.browserWaitUntil;
    if (config.flags.devtools) {
        config.testing.browserDevtools = true;
        config.testing.browserHeadless = false;
        env.__STENCIL_E2E_DEVTOOLS__ = 'true';
    }
    config.logger.debug(`puppeteer: ${puppeteerModulePath}`);
    config.logger.debug(`puppeteer headless: ${config.testing.browserHeadless}`);
    if (Array.isArray(config.testing.browserArgs)) {
        config.logger.debug(`puppeteer args: ${config.testing.browserArgs.join(' ')}`);
    }
    if (typeof config.testing.browserDevtools === 'boolean') {
        config.logger.debug(`puppeteer devtools: ${config.testing.browserDevtools}`);
    }
    if (typeof config.testing.browserSlowMo === 'number') {
        config.logger.debug(`puppeteer slowMo: ${config.testing.browserSlowMo}`);
    }
    const launchOpts = {
        ignoreHTTPSErrors: true,
        args: config.testing.browserArgs,
        headless: config.testing.browserHeadless,
        devtools: config.testing.browserDevtools,
        slowMo: config.testing.browserSlowMo,
    };
    if (config.testing.browserExecutablePath) {
        launchOpts.executablePath = config.testing.browserExecutablePath;
    }
    const browser = await (config.testing.browserWSEndpoint
        ? puppeteer.connect(Object.assign(Object.assign({}, launchOpts), { browserWSEndpoint: config.testing.browserWSEndpoint }))
        : puppeteer.launch(Object.assign({}, launchOpts)));
    env.__STENCIL_BROWSER_WS_ENDPOINT__ = browser.wsEndpoint();
    config.logger.debug(`puppeteer browser wsEndpoint: ${env.__STENCIL_BROWSER_WS_ENDPOINT__}`);
    return browser;
}
async function connectBrowser() {
    // the reason we're connecting to the browser from
    // a web socket is because jest probably has us
    // in a different thread, this is also why this
    // uses process.env for data
    const env = process.env;
    const wsEndpoint = env.__STENCIL_BROWSER_WS_ENDPOINT__;
    if (!wsEndpoint) {
        return null;
    }
    const connectOpts = {
        browserWSEndpoint: wsEndpoint,
        ignoreHTTPSErrors: true,
    };
    const puppeteer = require(env.__STENCIL_PUPPETEER_MODULE__);
    return await puppeteer.connect(connectOpts);
}
async function disconnectBrowser(browser) {
    if (browser) {
        try {
            browser.disconnect();
        }
        catch (e) { }
    }
}
function newBrowserPage(browser) {
    return browser.newPage();
}

function createJestPuppeteerEnvironment() {
    const NodeEnvironment = require('jest-environment-node');
    const JestEnvironment = class extends NodeEnvironment {
        constructor(config) {
            super(config);
            this.browser = null;
            this.pages = [];
        }
        async setup() {
            if (process.env.__STENCIL_E2E_TESTS__ === 'true') {
                this.global.__NEW_TEST_PAGE__ = this.newPuppeteerPage.bind(this);
                this.global.__CLOSE_OPEN_PAGES__ = this.closeOpenPages.bind(this);
            }
        }
        async newPuppeteerPage() {
            if (!this.browser) {
                // load the browser and page on demand
                this.browser = await connectBrowser();
            }
            const page = await newBrowserPage(this.browser);
            this.pages.push(page);
            const env = process.env;
            if (typeof env.__STENCIL_DEFAULT_TIMEOUT__ === 'string') {
                page.setDefaultTimeout(parseInt(env.__STENCIL_DEFAULT_TIMEOUT__, 10));
            }
            return page;
        }
        async closeOpenPages() {
            await Promise.all(this.pages.map(page => page.close()));
            this.pages.length = 0;
        }
        async teardown() {
            await super.teardown();
            await this.closeOpenPages();
            await disconnectBrowser(this.browser);
            this.browser = null;
        }
    };
    return JestEnvironment;
}

const IS_NODE_ENV = typeof global !== 'undefined' &&
    typeof require === 'function' &&
    !!global.process &&
    Array.isArray(global.process.argv) &&
    typeof __filename === 'string' &&
    (!global.origin || typeof global.origin !== 'string');
const IS_NODE_WINDOWS_ENV = IS_NODE_ENV && global.process.platform === 'win32';
const IS_LOCATION_ENV = typeof location !== 'undefined';
const IS_WEB_WORKER_ENV = typeof self !== 'undefined' && typeof self.importScripts === 'function' && typeof XMLHttpRequest !== 'undefined' && IS_LOCATION_ENV && typeof navigator !== 'undefined';
const IS_FETCH_ENV = typeof fetch === 'function';
const HAS_WEB_WORKER = typeof Worker === 'function' && IS_LOCATION_ENV;

const formatLazyBundleRuntimeMeta = (bundleId, cmps) => {
    return [bundleId, cmps.map(cmp => formatComponentRuntimeMeta(cmp, true))];
};
const formatComponentRuntimeMeta = (compilerMeta, includeMethods) => {
    let flags = 0;
    if (compilerMeta.encapsulation === 'shadow') {
        flags |= 1 /* shadowDomEncapsulation */;
        if (compilerMeta.shadowDelegatesFocus) {
            flags |= 16 /* shadowDelegatesFocus */;
        }
    }
    else if (compilerMeta.encapsulation === 'scoped') {
        flags |= 2 /* scopedCssEncapsulation */;
    }
    if (compilerMeta.encapsulation !== 'shadow' && compilerMeta.htmlTagNames.includes('slot')) {
        flags |= 4 /* hasSlotRelocation */;
    }
    if (compilerMeta.hasMode) {
        flags |= 32 /* hasMode */;
    }
    const members = formatComponentRuntimeMembers(compilerMeta, includeMethods);
    const hostListeners = formatHostListeners(compilerMeta);
    return trimFalsy([flags, compilerMeta.tagName, Object.keys(members).length > 0 ? members : undefined, hostListeners.length > 0 ? hostListeners : undefined]);
};
const formatComponentRuntimeMembers = (compilerMeta, includeMethods = true) => {
    return Object.assign(Object.assign(Object.assign({}, formatPropertiesRuntimeMember(compilerMeta.properties)), formatStatesRuntimeMember(compilerMeta.states)), (includeMethods ? formatMethodsRuntimeMember(compilerMeta.methods) : {}));
};
const formatPropertiesRuntimeMember = (properties) => {
    const runtimeMembers = {};
    properties.forEach(member => {
        runtimeMembers[member.name] = trimFalsy([
            /**
             * [0] member type
             */
            formatFlags(member),
            formatAttrName(member),
        ]);
    });
    return runtimeMembers;
};
const formatFlags = (compilerProperty) => {
    let type = formatPropType(compilerProperty.type);
    if (compilerProperty.mutable) {
        type |= 1024 /* Mutable */;
    }
    if (compilerProperty.reflect) {
        type |= 512 /* ReflectAttr */;
    }
    return type;
};
const formatAttrName = (compilerProperty) => {
    if (typeof compilerProperty.attribute === 'string') {
        // string attr name means we should observe this attribute
        if (compilerProperty.name === compilerProperty.attribute) {
            // property name and attribute name are the exact same
            // true value means to use the property name for the attribute name
            return undefined;
        }
        // property name and attribute name are not the same
        // so we need to return the actual string value
        // example: "multiWord" !== "multi-word"
        return compilerProperty.attribute;
    }
    // we shouldn't even observe an attribute for this property
    return undefined;
};
const formatPropType = (type) => {
    if (type === 'string') {
        return 1 /* String */;
    }
    if (type === 'number') {
        return 2 /* Number */;
    }
    if (type === 'boolean') {
        return 4 /* Boolean */;
    }
    if (type === 'any') {
        return 8 /* Any */;
    }
    return 16 /* Unknown */;
};
const formatStatesRuntimeMember = (states) => {
    const runtimeMembers = {};
    states.forEach(member => {
        runtimeMembers[member.name] = [
            32 /* State */,
        ];
    });
    return runtimeMembers;
};
const formatMethodsRuntimeMember = (methods) => {
    const runtimeMembers = {};
    methods.forEach(member => {
        runtimeMembers[member.name] = [
            64 /* Method */,
        ];
    });
    return runtimeMembers;
};
const formatHostListeners = (compilerMeta) => {
    return compilerMeta.listeners.map(compilerListener => {
        const hostListener = [computeListenerFlags(compilerListener), compilerListener.name, compilerListener.method];
        return hostListener;
    });
};
const computeListenerFlags = (listener) => {
    let flags = 0;
    if (listener.capture) {
        flags |= 2 /* Capture */;
    }
    if (listener.passive) {
        flags |= 1 /* Passive */;
    }
    switch (listener.target) {
        case 'document':
            flags |= 4 /* TargetDocument */;
            break;
        case 'window':
            flags |= 8 /* TargetWindow */;
            break;
        case 'parent':
            flags |= 16 /* TargetParent */;
            break;
        case 'body':
            flags |= 32 /* TargetBody */;
            break;
    }
    return flags;
};
const trimFalsy = (data) => {
    const arr = data;
    for (var i = arr.length - 1; i >= 0; i--) {
        if (arr[i]) {
            break;
        }
        // if falsy, safe to pop()
        arr.pop();
    }
    return arr;
};

const isDefined = (v) => v !== null && v !== undefined;
const isFunction = (v) => typeof v === 'function';
const isString = (v) => typeof v === 'string';
const isIterable = (v) => isDefined(v) && isFunction(v[Symbol.iterator]);

/**
 * Checks if the path is the OS root path, such as "/" or "C:\"
 */
const isRootPath = (p) => p === '/' || windowsPathRegex.test(p);
// https://github.com/nodejs/node/blob/5883a59b21a97e8b7339f435c977155a2c29ba8d/lib/path.js#L43
const windowsPathRegex = /^(?:[a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?[\\/]$/;

const splitLineBreaks = (sourceText) => {
    if (typeof sourceText !== 'string')
        return [];
    sourceText = sourceText.replace(/\\r/g, '\n');
    return sourceText.split('\n');
};

const hasError = (diagnostics) => {
    if (diagnostics == null || diagnostics.length === 0) {
        return false;
    }
    return diagnostics.some(d => d.level === 'error' && d.type !== 'runtime');
};
const hasWarning = (diagnostics) => {
    if (diagnostics == null || diagnostics.length === 0) {
        return false;
    }
    return diagnostics.some(d => d.level === 'warn');
};
const TASK_CANCELED_MSG = `task canceled`;

/**
 * Convert Windows backslash paths to slash paths: foo\\bar âž” foo/bar
 * Forward-slash paths can be used in Windows as long as they're not
 * extended-length paths and don't contain any non-ascii characters.
 * This was created since the path methods in Node.js outputs \\ paths on Windows.
 */
const normalizePath = (path) => {
    if (typeof path !== 'string') {
        throw new Error(`invalid path to normalize`);
    }
    path = normalizeSlashes(path.trim());
    const components = pathComponents(path, getRootLength(path));
    const reducedComponents = reducePathComponents(components);
    const rootPart = reducedComponents[0];
    const secondPart = reducedComponents[1];
    const normalized = rootPart + reducedComponents.slice(1).join('/');
    if (normalized === '') {
        return '.';
    }
    if (rootPart === '' && secondPart && path.includes('/') && !secondPart.startsWith('.') && !secondPart.startsWith('@')) {
        return './' + normalized;
    }
    return normalized;
};
const normalizeSlashes = (path) => path.replace(backslashRegExp, '/');
const altDirectorySeparator = '\\';
const urlSchemeSeparator = '://';
const backslashRegExp = /\\/g;
const reducePathComponents = (components) => {
    if (!Array.isArray(components) || components.length === 0) {
        return [];
    }
    const reduced = [components[0]];
    for (let i = 1; i < components.length; i++) {
        const component = components[i];
        if (!component)
            continue;
        if (component === '.')
            continue;
        if (component === '..') {
            if (reduced.length > 1) {
                if (reduced[reduced.length - 1] !== '..') {
                    reduced.pop();
                    continue;
                }
            }
            else if (reduced[0])
                continue;
        }
        reduced.push(component);
    }
    return reduced;
};
const getRootLength = (path) => {
    const rootLength = getEncodedRootLength(path);
    return rootLength < 0 ? ~rootLength : rootLength;
};
const getEncodedRootLength = (path) => {
    if (!path)
        return 0;
    const ch0 = path.charCodeAt(0);
    // POSIX or UNC
    if (ch0 === 47 /* slash */ || ch0 === 92 /* backslash */) {
        if (path.charCodeAt(1) !== ch0)
            return 1; // POSIX: "/" (or non-normalized "\")
        const p1 = path.indexOf(ch0 === 47 /* slash */ ? '/' : altDirectorySeparator, 2);
        if (p1 < 0)
            return path.length; // UNC: "//server" or "\\server"
        return p1 + 1; // UNC: "//server/" or "\\server\"
    }
    // DOS
    if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58 /* colon */) {
        const ch2 = path.charCodeAt(2);
        if (ch2 === 47 /* slash */ || ch2 === 92 /* backslash */)
            return 3; // DOS: "c:/" or "c:\"
        if (path.length === 2)
            return 2; // DOS: "c:" (but not "c:d")
    }
    // URL
    const schemeEnd = path.indexOf(urlSchemeSeparator);
    if (schemeEnd !== -1) {
        const authorityStart = schemeEnd + urlSchemeSeparator.length;
        const authorityEnd = path.indexOf('/', authorityStart);
        if (authorityEnd !== -1) {
            // URL: "file:///", "file://server/", "file://server/path"
            // For local "file" URLs, include the leading DOS volume (if present).
            // Per https://www.ietf.org/rfc/rfc1738.txt, a host of "" or "localhost" is a
            // special case interpreted as "the machine from which the URL is being interpreted".
            const scheme = path.slice(0, schemeEnd);
            const authority = path.slice(authorityStart, authorityEnd);
            if (scheme === 'file' && (authority === '' || authority === 'localhost') && isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {
                const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);
                if (volumeSeparatorEnd !== -1) {
                    if (path.charCodeAt(volumeSeparatorEnd) === 47 /* slash */) {
                        // URL: "file:///c:/", "file://localhost/c:/", "file:///c%3a/", "file://localhost/c%3a/"
                        return ~(volumeSeparatorEnd + 1);
                    }
                    if (volumeSeparatorEnd === path.length) {
                        // URL: "file:///c:", "file://localhost/c:", "file:///c$3a", "file://localhost/c%3a"
                        // but not "file:///c:d" or "file:///c%3ad"
                        return ~volumeSeparatorEnd;
                    }
                }
            }
            return ~(authorityEnd + 1); // URL: "file://server/", "http://server/"
        }
        return ~path.length; // URL: "file://server", "http://server"
    }
    // relative
    return 0;
};
const isVolumeCharacter = (charCode) => (charCode >= 97 /* a */ && charCode <= 122 /* z */) || (charCode >= 65 /* A */ && charCode <= 90 /* Z */);
const getFileUrlVolumeSeparatorEnd = (url, start) => {
    const ch0 = url.charCodeAt(start);
    if (ch0 === 58 /* colon */)
        return start + 1;
    if (ch0 === 37 /* percent */ && url.charCodeAt(start + 1) === 51 /* _3 */) {
        const ch2 = url.charCodeAt(start + 2);
        if (ch2 === 97 /* a */ || ch2 === 65 /* A */)
            return start + 3;
    }
    return -1;
};
const pathComponents = (path, rootLength) => {
    const root = path.substring(0, rootLength);
    const rest = path.substring(rootLength).split('/');
    const restLen = rest.length;
    if (restLen > 0 && !rest[restLen - 1]) {
        rest.pop();
    }
    return [root, ...rest];
};
/**
 * Same as normalizePath(), expect it'll also strip any querystrings
 * from the path name. So /dir/file.css?tag=cmp-a becomes /dir/file.css
 */
const normalizeFsPath = (p) => normalizePath(p.split('?')[0]);

const loadTypeScriptDiagnostic = (tsDiagnostic) => {
    const d = {
        level: 'warn',
        type: 'typescript',
        language: 'typescript',
        header: 'TypeScript',
        code: tsDiagnostic.code.toString(),
        messageText: flattenDiagnosticMessageText(tsDiagnostic, tsDiagnostic.messageText),
        relFilePath: null,
        absFilePath: null,
        lines: [],
    };
    if (tsDiagnostic.category === 1) {
        d.level = 'error';
    }
    if (tsDiagnostic.file) {
        d.absFilePath = tsDiagnostic.file.fileName;
        const sourceText = tsDiagnostic.file.text;
        const srcLines = splitLineBreaks(sourceText);
        const posData = tsDiagnostic.file.getLineAndCharacterOfPosition(tsDiagnostic.start);
        const errorLine = {
            lineIndex: posData.line,
            lineNumber: posData.line + 1,
            text: srcLines[posData.line],
            errorCharStart: posData.character,
            errorLength: Math.max(tsDiagnostic.length, 1),
        };
        d.lineNumber = errorLine.lineNumber;
        d.columnNumber = errorLine.errorCharStart + 1;
        d.lines.push(errorLine);
        if (errorLine.errorLength === 0 && errorLine.errorCharStart > 0) {
            errorLine.errorLength = 1;
            errorLine.errorCharStart--;
        }
        if (errorLine.lineIndex > 0) {
            const previousLine = {
                lineIndex: errorLine.lineIndex - 1,
                lineNumber: errorLine.lineNumber - 1,
                text: srcLines[errorLine.lineIndex - 1],
                errorCharStart: -1,
                errorLength: -1,
            };
            d.lines.unshift(previousLine);
        }
        if (errorLine.lineIndex + 1 < srcLines.length) {
            const nextLine = {
                lineIndex: errorLine.lineIndex + 1,
                lineNumber: errorLine.lineNumber + 1,
                text: srcLines[errorLine.lineIndex + 1],
                errorCharStart: -1,
                errorLength: -1,
            };
            d.lines.push(nextLine);
        }
    }
    return d;
};
const flattenDiagnosticMessageText = (tsDiagnostic, diag) => {
    if (typeof diag === 'string') {
        return diag;
    }
    else if (diag === undefined) {
        return '';
    }
    const ignoreCodes = [];
    const isStencilConfig = tsDiagnostic.file.fileName.includes('stencil.config');
    if (isStencilConfig) {
        ignoreCodes.push(2322);
    }
    let result = '';
    if (!ignoreCodes.includes(diag.code)) {
        result = diag.messageText;
        if (isIterable(diag.next)) {
            for (const kid of diag.next) {
                result += flattenDiagnosticMessageText(tsDiagnostic, kid);
            }
        }
    }
    if (isStencilConfig) {
        result = result.replace(`type 'StencilConfig'`, `Stencil Config`);
        result = result.replace(`Object literal may only specify known properties, but `, ``);
        result = result.replace(`Object literal may only specify known properties, and `, ``);
    }
    return result.trim();
};

const isOutputTargetDistLazy = (o) => o.type === DIST_LAZY;
const isOutputTargetWww = (o) => o.type === WWW;
const DIST_LAZY = `dist-lazy`;
const WWW = `www`;

function shuffleArray(array) {
    // http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
    let currentIndex = array.length;
    let temporaryValue;
    let randomIndex;
    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
    return array;
}
function getAppScriptUrl(config, browserUrl) {
    const appFileName = `${config.fsNamespace}.esm.js`;
    return getAppUrl(config, browserUrl, appFileName);
}
function getAppStyleUrl(config, browserUrl) {
    if (config.globalStyle) {
        const appFileName = `${config.fsNamespace}.css`;
        return getAppUrl(config, browserUrl, appFileName);
    }
    return null;
}
function getAppUrl(config, browserUrl, appFileName) {
    const wwwOutput = config.outputTargets.find(isOutputTargetWww);
    if (wwwOutput) {
        const appBuildDir = wwwOutput.buildDir;
        const appFilePath = path$1.join(appBuildDir, appFileName);
        const appUrlPath = path$1.relative(wwwOutput.dir, appFilePath);
        const url = new URL(appUrlPath, browserUrl);
        return url.href;
    }
    const distOutput = config.outputTargets.find(isOutputTargetDistLazy);
    if (distOutput) {
        const appBuildDir = distOutput.esmDir;
        const appFilePath = path$1.join(appBuildDir, appFileName);
        const appUrlPath = path$1.relative(config.rootDir, appFilePath);
        const url = new URL(appUrlPath, browserUrl);
        return url.href;
    }
    return browserUrl;
}

function buildJestArgv(config) {
    const yargs = require('yargs');
    const args = [...config.flags.unknownArgs.slice(), ...config.flags.knownArgs.slice()];
    if (!args.some(a => a.startsWith('--max-workers') || a.startsWith('--maxWorkers'))) {
        args.push(`--max-workers=${config.maxConcurrentWorkers}`);
    }
    if (config.flags.devtools) {
        args.push('--runInBand');
    }
    config.logger.info(config.logger.magenta(`jest args: ${args.join(' ')}`));
    const { options } = require('jest-cli/build/cli/args');
    const jestArgv = yargs(args).options(options).argv;
    jestArgv.config = buildJestConfig(config);
    if (typeof jestArgv.maxWorkers === 'string') {
        try {
            jestArgv.maxWorkers = parseInt(jestArgv.maxWorkers, 10);
        }
        catch (e) { }
    }
    if (typeof jestArgv.ci === 'string') {
        jestArgv.ci = jestArgv.ci === 'true' || jestArgv.ci === '';
    }
    return jestArgv;
}
function buildJestConfig(config) {
    const stencilConfigTesting = config.testing;
    const jestDefaults = require('jest-config').defaults;
    const validJestConfigKeys = Object.keys(jestDefaults);
    const jestConfig = {};
    Object.keys(stencilConfigTesting).forEach(key => {
        if (validJestConfigKeys.includes(key)) {
            jestConfig[key] = stencilConfigTesting[key];
        }
    });
    // https://github.com/facebook/jest/commit/8d3ddd5db440088f4488fbb4aaffe8ae4f5401e5#diff-7677b25b723832a937d598022186bd20
    jestConfig.rootDir = config.rootDir;
    if (isString(stencilConfigTesting.collectCoverage)) {
        jestConfig.collectCoverage = stencilConfigTesting.collectCoverage;
    }
    if (isString(stencilConfigTesting.coverageDirectory)) {
        jestConfig.coverageDirectory = stencilConfigTesting.coverageDirectory;
    }
    if (isString(stencilConfigTesting.coverageThreshold)) {
        jestConfig.coverageThreshold = stencilConfigTesting.coverageThreshold;
    }
    if (isString(stencilConfigTesting.globalSetup)) {
        jestConfig.globalSetup = stencilConfigTesting.globalSetup;
    }
    if (isString(stencilConfigTesting.globalTeardown)) {
        jestConfig.globalTeardown = stencilConfigTesting.globalTeardown;
    }
    if (isString(stencilConfigTesting.preset)) {
        jestConfig.preset = stencilConfigTesting.preset;
    }
    if (stencilConfigTesting.projects) {
        jestConfig.projects = stencilConfigTesting.projects;
    }
    if (Array.isArray(stencilConfigTesting.reporters)) {
        jestConfig.reporters = stencilConfigTesting.reporters;
    }
    if (isString(stencilConfigTesting.testResultsProcessor)) {
        jestConfig.testResultsProcessor = stencilConfigTesting.testResultsProcessor;
    }
    if (stencilConfigTesting.transform) {
        jestConfig.transform = stencilConfigTesting.transform;
    }
    if (stencilConfigTesting.verbose) {
        jestConfig.verbose = stencilConfigTesting.verbose;
    }
    return JSON.stringify(jestConfig);
}
function getProjectListFromCLIArgs(config, argv) {
    const projects = argv.projects ? argv.projects : [];
    projects.push(config.rootDir);
    return projects;
}

function setScreenshotEmulateData(userEmulateConfig, env) {
    const screenshotEmulate = {
        userAgent: 'default',
        viewport: {
            width: 800,
            height: 600,
            deviceScaleFactor: 1,
            isMobile: false,
            hasTouch: false,
            isLandscape: false,
        },
    };
    if (typeof userEmulateConfig.device === 'string') {
        try {
            const deviceDescriptors = require(env.__STENCIL_PUPPETEER_MODULE__ + '/DeviceDescriptors');
            const puppeteerEmulateOpts = deviceDescriptors[userEmulateConfig.device];
            if (!puppeteerEmulateOpts) {
                console.error(`invalid emulate device: ${userEmulateConfig.device}`);
                return;
            }
            screenshotEmulate.device = userEmulateConfig.device;
            screenshotEmulate.userAgent = puppeteerEmulateOpts.userAgent;
            screenshotEmulate.viewport = puppeteerEmulateOpts.viewport;
        }
        catch (e) {
            console.error('error loading puppeteer DeviceDescriptors', e);
            return;
        }
    }
    if (userEmulateConfig.viewport) {
        if (typeof userEmulateConfig.viewport.width === 'number') {
            screenshotEmulate.viewport.width = userEmulateConfig.viewport.width;
        }
        if (typeof userEmulateConfig.viewport.height === 'number') {
            screenshotEmulate.viewport.height = userEmulateConfig.viewport.height;
        }
        if (typeof userEmulateConfig.viewport.deviceScaleFactor === 'number') {
            screenshotEmulate.viewport.deviceScaleFactor = userEmulateConfig.viewport.deviceScaleFactor;
        }
        if (typeof userEmulateConfig.viewport.hasTouch === 'boolean') {
            screenshotEmulate.viewport.hasTouch = userEmulateConfig.viewport.hasTouch;
        }
        if (typeof userEmulateConfig.viewport.isLandscape === 'boolean') {
            screenshotEmulate.viewport.isLandscape = userEmulateConfig.viewport.isLandscape;
        }
        if (typeof userEmulateConfig.viewport.isMobile === 'boolean') {
            screenshotEmulate.viewport.isMobile = userEmulateConfig.viewport.isMobile;
        }
        if (typeof userEmulateConfig.userAgent === 'string') {
            screenshotEmulate.userAgent = userEmulateConfig.userAgent;
        }
    }
    env.__STENCIL_EMULATE__ = JSON.stringify(screenshotEmulate);
}

async function runJest(config, env) {
    let success = false;
    try {
        // set all of the emulate configs to the process.env to be read later on
        const emulateConfigs = getEmulateConfigs(config.testing, config.flags);
        env.__STENCIL_EMULATE_CONFIGS__ = JSON.stringify(emulateConfigs);
        if (config.flags.ci || config.flags.e2e) {
            env.__STENCIL_DEFAULT_TIMEOUT__ = '30000';
        }
        else {
            env.__STENCIL_DEFAULT_TIMEOUT__ = '15000';
        }
        if (config.flags.devtools) {
            env.__STENCIL_DEFAULT_TIMEOUT__ = '300000000';
        }
        config.logger.debug(`default timeout: ${env.__STENCIL_DEFAULT_TIMEOUT__}`);
        // build up our args from our already know list of args in the config
        const jestArgv = buildJestArgv(config);
        // build up the project paths, which is basically the app's root dir
        const projects = getProjectListFromCLIArgs(config, jestArgv);
        // run the @jest/core with our data rather than letting the
        // @jest/core parse the args itself
        const { runCLI } = require('@jest/core');
        const cliResults = (await runCLI(jestArgv, projects));
        success = !!cliResults.results.success;
    }
    catch (e) {
        config.logger.error(`runJest: ${e}`);
    }
    return success;
}
function createTestRunner() {
    const TestRunner = require('jest-runner');
    class StencilTestRunner extends TestRunner {
        async runTests(tests, watcher, onStart, onResult, onFailure, options) {
            const env = process.env;
            // filter out only the tests the flags said we should run
            tests = tests.filter(t => includeTestFile(t.path, env));
            if (env.__STENCIL_SCREENSHOT__ === 'true') {
                // we're doing e2e screenshots, so let's loop through
                // each of the emulate configs for each test
                // get the emulate configs from the process env
                // and parse the emulate config data
                const emulateConfigs = JSON.parse(env.__STENCIL_EMULATE_CONFIGS__);
                // loop through each emulate config to re-run the tests per config
                for (let i = 0; i < emulateConfigs.length; i++) {
                    const emulateConfig = emulateConfigs[i];
                    // reset the environment for each emulate config
                    setScreenshotEmulateData(emulateConfig, env);
                    // run the test for each emulate config
                    await super.runTests(tests, watcher, onStart, onResult, onFailure, options);
                }
            }
            else {
                // not doing e2e screenshot tests
                // so just run each test once
                await super.runTests(tests, watcher, onStart, onResult, onFailure, options);
            }
        }
    }
    return StencilTestRunner;
}
function includeTestFile(testPath, env) {
    testPath = testPath.toLowerCase().replace(/\\/g, '/');
    const hasE2E = testPath.includes('.e2e.') || testPath.includes('/e2e.');
    if (env.__STENCIL_E2E_TESTS__ === 'true' && hasE2E) {
        // keep this test if it's an e2e file and we should be testing e2e
        return true;
    }
    if (env.__STENCIL_SPEC_TESTS__ === 'true' && !hasE2E) {
        // keep this test if it's a spec file and we should be testing unit tests
        return true;
    }
    return false;
}
function getEmulateConfigs(testing, flags) {
    let emulateConfigs = testing.emulate.slice();
    if (typeof flags.emulate === 'string') {
        const emulateFlag = flags.emulate.toLowerCase();
        emulateConfigs = emulateConfigs.filter(emulateConfig => {
            if (typeof emulateConfig.device === 'string' && emulateConfig.device.toLowerCase() === emulateFlag) {
                return true;
            }
            if (typeof emulateConfig.userAgent === 'string' && emulateConfig.userAgent.toLowerCase().includes(emulateFlag)) {
                return true;
            }
            return false;
        });
    }
    return emulateConfigs;
}

async function runJestScreenshot(config, env) {
    config.logger.debug(`screenshot connector: ${config.testing.screenshotConnector}`);
    const ScreenshotConnector = require(config.testing.screenshotConnector);
    const connector = new ScreenshotConnector();
    // for CI, let's wait a little longer than locally before taking the screenshot
    const pixelmatchModulePath = path$1.join(config.sys.getCompilerExecutingPath(), '..', '..', 'screenshot', 'pixel-match.js');
    config.logger.debug(`pixelmatch module: ${pixelmatchModulePath}`);
    const initTimespan = config.logger.createTimeSpan(`screenshot, initBuild started`, true);
    await connector.initBuild({
        buildId: createBuildId(),
        buildMessage: createBuildMessage(),
        buildTimestamp: Date.now(),
        appNamespace: config.namespace,
        rootDir: config.rootDir,
        cacheDir: config.cacheDir,
        packageDir: path$1.join(config.sys.getCompilerExecutingPath(), '..', '..'),
        updateMaster: config.flags.updateScreenshot,
        logger: config.logger,
        allowableMismatchedPixels: config.testing.allowableMismatchedPixels,
        allowableMismatchedRatio: config.testing.allowableMismatchedRatio,
        pixelmatchThreshold: config.testing.pixelmatchThreshold,
        waitBeforeScreenshot: config.testing.waitBeforeScreenshot,
        pixelmatchModulePath: pixelmatchModulePath,
    });
    if (!config.flags.updateScreenshot) {
        await connector.pullMasterBuild();
    }
    initTimespan.finish(`screenshot, initBuild finished`);
    const dataPromises = await Promise.all([await connector.getMasterBuild(), await connector.getScreenshotCache()]);
    const masterBuild = dataPromises[0];
    const screenshotCache = dataPromises[1];
    env.__STENCIL_SCREENSHOT_BUILD__ = connector.toJson(masterBuild, screenshotCache);
    const testsTimespan = config.logger.createTimeSpan(`screenshot, tests started`, true);
    const passed = await runJest(config, env);
    testsTimespan.finish(`screenshot, tests finished, passed: ${passed}`);
    try {
        const completeTimespan = config.logger.createTimeSpan(`screenshot, completeTimespan started`, true);
        let results = await connector.completeBuild(masterBuild);
        completeTimespan.finish(`screenshot, completeTimespan finished`);
        if (results) {
            const publishTimespan = config.logger.createTimeSpan(`screenshot, publishBuild started`, true);
            results = await connector.publishBuild(results);
            publishTimespan.finish(`screenshot, publishBuild finished`);
            if (config.flags.updateScreenshot) {
                // updating the master screenshot
                if (results.currentBuild && typeof results.currentBuild.previewUrl === 'string') {
                    config.logger.info(config.logger.magenta(results.currentBuild.previewUrl));
                }
            }
            else {
                // comparing the screenshot to master
                if (results.compare) {
                    try {
                        await connector.updateScreenshotCache(screenshotCache, results);
                    }
                    catch (e) {
                        config.logger.error(e);
                    }
                    config.logger.info(`screenshots compared: ${results.compare.diffs.length}`);
                    if (typeof results.compare.url === 'string') {
                        config.logger.info(config.logger.magenta(results.compare.url));
                    }
                }
            }
        }
    }
    catch (e) {
        config.logger.error(e, e.stack);
    }
    return passed;
}
function createBuildId() {
    const d = new Date();
    let fmDt = d.getFullYear() + '';
    fmDt += ('0' + (d.getMonth() + 1)).slice(-2);
    fmDt += ('0' + d.getDate()).slice(-2);
    fmDt += ('0' + d.getHours()).slice(-2);
    fmDt += ('0' + d.getMinutes()).slice(-2);
    fmDt += ('0' + d.getSeconds()).slice(-2);
    return fmDt;
}
function createBuildMessage() {
    const d = new Date();
    let fmDt = d.getFullYear() + '' + '-';
    fmDt += ('0' + (d.getMonth() + 1)).slice(-2) + '-';
    fmDt += ('0' + d.getDate()).slice(-2) + ' ';
    fmDt += ('0' + d.getHours()).slice(-2) + ':';
    fmDt += ('0' + d.getMinutes()).slice(-2) + ':';
    fmDt += ('0' + d.getSeconds()).slice(-2);
    return `Build: ${fmDt}`;
}

const createTesting = async (config) => {
    config = setupTestingConfig(config);
    const { createCompiler } = require('../compiler/stencil.js');
    const compiler = await createCompiler(config);
    let devServer;
    let puppeteerBrowser;
    const run = async (opts = {}) => {
        let doScreenshots = false;
        let passed = false;
        let env;
        const msg = [];
        try {
            if (!opts.spec && !opts.e2e) {
                config.logger.error(`Testing requires either the --spec or --e2e command line flags, or both. For example, to run unit tests, use the command: stencil test --spec`);
                return false;
            }
            env = process.env;
            if (opts.e2e) {
                msg.push('e2e');
                env.__STENCIL_E2E_TESTS__ = 'true';
            }
            if (opts.spec) {
                msg.push('spec');
                env.__STENCIL_SPEC_TESTS__ = 'true';
            }
            config.logger.info(config.logger.magenta(`testing ${msg.join(' and ')} files`));
            doScreenshots = !!(opts.e2e && opts.screenshot);
            if (doScreenshots) {
                env.__STENCIL_SCREENSHOT__ = 'true';
                if (opts.updateScreenshot) {
                    config.logger.info(config.logger.magenta(`updating master screenshots`));
                }
                else {
                    config.logger.info(config.logger.magenta(`comparing against master screenshots`));
                }
            }
            if (opts.e2e) {
                // e2e tests only
                // do a build, start a dev server
                // and spin up a puppeteer browser
                let buildTask = null;
                config.outputTargets.forEach(outputTarget => {
                    outputTarget.empty = false;
                });
                const doBuild = !(config.flags && config.flags.build === false);
                if (doBuild) {
                    buildTask = compiler.build();
                }
                config.devServer.openBrowser = false;
                config.devServer.gzip = false;
                config.devServer.reloadStrategy = null;
                const startupResults = await Promise.all([index_js.startServer(config.devServer, config.logger), startPuppeteerBrowser(config)]);
                devServer = startupResults[0];
                puppeteerBrowser = startupResults[1];
                if (doBuild) {
                    const results = await buildTask;
                    if (!results || (!config.watch && hasError(results && results.diagnostics))) {
                        await destroy();
                        return false;
                    }
                }
                if (devServer) {
                    env.__STENCIL_BROWSER_URL__ = devServer.browserUrl;
                    config.logger.debug(`e2e dev server url: ${env.__STENCIL_BROWSER_URL__}`);
                    env.__STENCIL_APP_SCRIPT_URL__ = getAppScriptUrl(config, devServer.browserUrl);
                    config.logger.debug(`e2e app script url: ${env.__STENCIL_APP_SCRIPT_URL__}`);
                    const styleUrl = getAppStyleUrl(config, devServer.browserUrl);
                    if (styleUrl) {
                        env.__STENCIL_APP_STYLE_URL__ = getAppStyleUrl(config, devServer.browserUrl);
                        config.logger.debug(`e2e app style url: ${env.__STENCIL_APP_STYLE_URL__}`);
                    }
                }
            }
        }
        catch (e) {
            config.logger.error(e);
            return false;
        }
        try {
            if (doScreenshots) {
                passed = await runJestScreenshot(config, env);
            }
            else {
                passed = await runJest(config, env);
            }
            config.logger.info('');
        }
        catch (e) {
            config.logger.error(e);
        }
        return passed;
    };
    const destroy = async () => {
        const closingTime = []; // you don't have to go home but you can't stay here
        if (config) {
            if (config.sys && config.sys.destroy) {
                closingTime.push(config.sys.destroy());
            }
            config = null;
        }
        if (devServer) {
            if (devServer.close) {
                closingTime.push(devServer.close());
            }
            devServer = null;
        }
        if (puppeteerBrowser) {
            if (puppeteerBrowser.close) {
                closingTime.push(puppeteerBrowser.close());
            }
            puppeteerBrowser = null;
        }
        await Promise.all(closingTime);
    };
    return {
        destroy,
        run,
    };
};
function setupTestingConfig(config) {
    config.buildEs5 = false;
    config.devMode = true;
    config.minifyCss = false;
    config.minifyJs = false;
    config.hashFileNames = false;
    config.validateTypes = false;
    config._isTesting = true;
    config.buildDist = true;
    config.flags = config.flags || {};
    config.flags.serve = false;
    config.flags.open = false;
    config.outputTargets.forEach(o => {
        if (o.type === 'www') {
            o.serviceWorker = null;
        }
    });
    return config;
}

function transpile(input, opts = {}) {
    opts = Object.assign(Object.assign({}, opts), { componentExport: null, componentMetadata: 'compilerstatic', coreImportPath: isString(opts.coreImportPath) ? opts.coreImportPath : '@stencil/core/internal/testing', currentDirectory: opts.currentDirectory || process.cwd(), module: 'cjs', proxy: null, sourceMap: 'inline', style: null, target: 'es2015' });
    try {
        const v = process.version.replace('v', '').split('.');
        if (parseInt(v[0], 10) >= 10) {
            // let's go with ES2017 for node 10 and above
            opts.target = 'es2017';
        }
    }
    catch (e) { }
    return stencil_js.transpileSync(input, opts);
}

const jestPreprocessor = {
    process(sourceText, filePath, jestConfig) {
        if (shouldTransform(filePath, sourceText)) {
            const opts = {
                file: filePath,
                currentDirectory: jestConfig.rootDir,
            };
            const tsCompilerOptions = this.getCompilerOptions(jestConfig.rootDir);
            if (tsCompilerOptions) {
                if (tsCompilerOptions.baseUrl) {
                    opts.baseUrl = tsCompilerOptions.baseUrl;
                }
                if (tsCompilerOptions.paths) {
                    opts.paths = tsCompilerOptions.paths;
                }
            }
            const results = transpile(sourceText, opts);
            const hasErrors = results.diagnostics.some(diagnostic => diagnostic.level === 'error');
            if (results.diagnostics && hasErrors) {
                const msg = results.diagnostics.map(formatDiagnostic).join('\n\n');
                throw new Error(msg);
            }
            return results.code;
        }
        return sourceText;
    },
    getCompilerOptions(rootDir) {
        if (!this._tsCompilerOptions) {
            this._tsCompilerOptions = getCompilerOptions(rootDir);
        }
        return this._tsCompilerOptions;
    },
    getCacheKey(code, filePath, jestConfigStr, transformOptions) {
        // https://github.com/facebook/jest/blob/v23.6.0/packages/jest-runtime/src/script_transformer.js#L61-L90
        if (!this._tsCompilerOptionsKey) {
            const opts = this.getCompilerOptions(transformOptions.rootDir);
            this._tsCompilerOptionsKey = JSON.stringify(opts);
        }
        const key = [
            process.version,
            this._tsCompilerOptionsKey,
            code,
            filePath,
            jestConfigStr,
            !!transformOptions.instrument,
            4,
        ];
        return key.join(':');
    },
};
function formatDiagnostic(diagnostic) {
    let m = '';
    if (diagnostic.relFilePath) {
        m += diagnostic.relFilePath;
        if (typeof diagnostic.lineNumber === 'number') {
            m += ':' + diagnostic.lineNumber + 1;
            if (typeof diagnostic.columnNumber === 'number') {
                m += ':' + diagnostic.columnNumber;
            }
        }
        m += '\n';
    }
    m += diagnostic.messageText;
    return m;
}
function getCompilerOptions(rootDir) {
    if (typeof rootDir !== 'string') {
        return null;
    }
    rootDir = normalizePath(rootDir);
    const tsconfigFilePath = ts.findConfigFile(rootDir, ts.sys.fileExists);
    if (!tsconfigFilePath) {
        return null;
    }
    const tsconfigResults = ts.readConfigFile(tsconfigFilePath, ts.sys.readFile);
    if (tsconfigResults.error) {
        throw new Error(formatDiagnostic(loadTypeScriptDiagnostic(tsconfigResults.error)));
    }
    const parseResult = ts.parseJsonConfigFileContent(tsconfigResults.config, ts.sys, rootDir, undefined, tsconfigFilePath);
    return parseResult.options;
}
function shouldTransform(filePath, sourceText) {
    const ext = filePath.split('.').pop().toLowerCase().split('?')[0];
    if (ext === 'ts' || ext === 'tsx' || ext === 'jsx') {
        // typescript extensions (to include .d.ts)
        return true;
    }
    if (ext === 'mjs') {
        // es module extensions
        return true;
    }
    if (ext === 'js') {
        // there may be false positives here
        // but worst case scenario a commonjs file is transpiled to commonjs
        if (sourceText.includes('import ') || sourceText.includes('import.') || sourceText.includes('import(')) {
            return true;
        }
        if (sourceText.includes('export ')) {
            return true;
        }
    }
    if (ext === 'css') {
        // convert a standard css file into an nodejs ready file
        return true;
    }
    return false;
}

function toEqualAttribute(elm, expectAttrName, expectAttrValue) {
    if (!elm) {
        throw new Error(`expect toMatchAttribute value is null`);
    }
    if (typeof elm.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    if (elm.nodeType !== 1 /* ELEMENT_NODE */) {
        throw new Error(`expect toMatchAttribute value is not an element`);
    }
    let receivedAttrValue = elm.getAttribute(expectAttrName);
    if (expectAttrValue != null) {
        expectAttrValue = String(expectAttrValue);
    }
    if (receivedAttrValue != null) {
        receivedAttrValue = String(receivedAttrValue);
    }
    const pass = expectAttrValue === receivedAttrValue;
    return {
        message: () => `expected attribute ${expectAttrName} "${expectAttrValue}" to ${pass ? 'not ' : ''}equal "${receivedAttrValue}"`,
        pass: pass,
    };
}
function toEqualAttributes(elm, expectAttrs) {
    if (!elm) {
        throw new Error(`expect toEqualAttributes value is null`);
    }
    if (typeof elm.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    if (elm.nodeType !== 1 /* ELEMENT_NODE */) {
        throw new Error(`expect toEqualAttributes value is not an element`);
    }
    const attrNames = Object.keys(expectAttrs);
    const pass = attrNames.every(attrName => {
        let expectAttrValue = expectAttrs[attrName];
        if (expectAttrValue != null) {
            expectAttrValue = String(expectAttrValue);
        }
        return elm.getAttribute(attrName) === expectAttrValue;
    });
    return {
        message: () => `expected attributes to ${pass ? 'not ' : ''}equal ${attrNames.map(a => `[${a}="${expectAttrs[a]}"]`).join(', ')}`,
        pass: pass,
    };
}
function toHaveAttribute(elm, expectAttrName) {
    if (!elm) {
        throw new Error(`expect toHaveAttribute value is null`);
    }
    if (typeof elm.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    if (elm.nodeType !== 1 /* ELEMENT_NODE */) {
        throw new Error(`expect toHaveAttribute value is not an element`);
    }
    const pass = elm.hasAttribute(expectAttrName);
    return {
        message: () => `expected to ${pass ? 'not ' : ''}have the attribute "${expectAttrName}"`,
        pass: pass,
    };
}

function toHaveReceivedEvent(eventSpy) {
    if (!eventSpy) {
        throw new Error(`toHaveReceivedEvent event spy is null`);
    }
    if (typeof eventSpy.then === 'function') {
        throw new Error(`event spy must be a resolved value, not a promise, before it can be tested`);
    }
    if (!eventSpy.eventName) {
        throw new Error(`toHaveReceivedEvent did not receive an event spy`);
    }
    const pass = eventSpy.events.length > 0;
    return {
        message: () => `expected to have ${pass ? 'not ' : ''}called "${eventSpy.eventName}" event`,
        pass: pass,
    };
}
function toHaveReceivedEventTimes(eventSpy, count) {
    if (!eventSpy) {
        throw new Error(`toHaveReceivedEventTimes event spy is null`);
    }
    if (typeof eventSpy.then === 'function') {
        throw new Error(`event spy must be a resolved value, not a promise, before it can be tested`);
    }
    if (!eventSpy.eventName) {
        throw new Error(`toHaveReceivedEventTimes did not receive an event spy`);
    }
    const pass = eventSpy.length === count;
    return {
        message: () => `expected event "${eventSpy.eventName}" to have been called ${count} times, but was called ${eventSpy.events.length} time${eventSpy.events.length > 1 ? 's' : ''}`,
        pass: pass,
    };
}
function toHaveReceivedEventDetail(eventSpy, eventDetail) {
    if (!eventSpy) {
        throw new Error(`toHaveReceivedEventDetail event spy is null`);
    }
    if (typeof eventSpy.then === 'function') {
        throw new Error(`event spy must be a resolved value, not a promise, before it can be tested`);
    }
    if (!eventSpy.eventName) {
        throw new Error(`toHaveReceivedEventDetail did not receive an event spy`);
    }
    if (!eventSpy.lastEvent) {
        throw new Error(`event "${eventSpy.eventName}" was not received`);
    }
    const pass = deepEqual(eventSpy.lastEvent.detail, eventDetail);
    expect(eventSpy.lastEvent.detail).toEqual(eventDetail);
    return {
        message: () => `expected event "${eventSpy.eventName}" detail to ${pass ? 'not ' : ''}equal`,
        pass: pass,
    };
}
function toHaveFirstReceivedEventDetail(eventSpy, eventDetail) {
    if (!eventSpy) {
        throw new Error(`toHaveFirstReceivedEventDetail event spy is null`);
    }
    if (typeof eventSpy.then === 'function') {
        throw new Error(`event spy must be a resolved value, not a promise, before it can be tested`);
    }
    if (!eventSpy.eventName) {
        throw new Error(`toHaveFirstReceivedEventDetail did not receive an event spy`);
    }
    if (!eventSpy.firstEvent) {
        throw new Error(`event "${eventSpy.eventName}" was not received`);
    }
    const pass = deepEqual(eventSpy.firstEvent.detail, eventDetail);
    expect(eventSpy.lastEvent.detail).toEqual(eventDetail);
    return {
        message: () => `expected event "${eventSpy.eventName}" detail to ${pass ? 'not ' : ''}equal`,
        pass: pass,
    };
}
function toHaveNthReceivedEventDetail(eventSpy, index, eventDetail) {
    if (!eventSpy) {
        throw new Error(`toHaveNthReceivedEventDetail event spy is null`);
    }
    if (typeof eventSpy.then === 'function') {
        throw new Error(`event spy must be a resolved value, not a promise, before it can be tested`);
    }
    if (!eventSpy.eventName) {
        throw new Error(`toHaveNthReceivedEventDetail did not receive an event spy`);
    }
    if (!eventSpy.firstEvent) {
        throw new Error(`event "${eventSpy.eventName}" was not received`);
    }
    const event = eventSpy.events[index];
    if (!event) {
        throw new Error(`event at index ${index} was not received`);
    }
    const pass = deepEqual(event.detail, eventDetail);
    expect(event.detail).toEqual(eventDetail);
    return {
        message: () => `expected event "${eventSpy.eventName}" detail to ${pass ? 'not ' : ''}equal`,
        pass: pass,
    };
}
// from https://www.npmjs.com/package/fast-deep-equal
// License in NOTICE.md
const deepEqual = function equal(a, b) {
    if (a === b)
        return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
        if (arrA && arrB) {
            length = a.length;
            if (length != b.length)
                return false;
            for (i = length; i-- !== 0;)
                if (!equal(a[i], b[i]))
                    return false;
            return true;
        }
        if (arrA != arrB)
            return false;
        var dateA = a instanceof Date, dateB = b instanceof Date;
        if (dateA != dateB)
            return false;
        if (dateA && dateB)
            return a.getTime() == b.getTime();
        var regexpA = a instanceof RegExp, regexpB = b instanceof RegExp;
        if (regexpA != regexpB)
            return false;
        if (regexpA && regexpB)
            return a.toString() == b.toString();
        var keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
            return false;
        for (i = length; i-- !== 0;)
            if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
                return false;
        for (i = length; i-- !== 0;) {
            key = keys[i];
            if (!equal(a[key], b[key]))
                return false;
        }
        return true;
    }
    return a !== a && b !== b;
};

function toEqualHtml(input, shouldEqual) {
    return compareHtml(input, shouldEqual, true);
}
function toEqualLightHtml(input, shouldEqual) {
    return compareHtml(input, shouldEqual, false);
}
function compareHtml(input, shouldEqual, serializeShadowRoot) {
    if (input == null) {
        throw new Error(`expect toEqualHtml() value is "${input}"`);
    }
    if (typeof input.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    let serializeA;
    if (input.nodeType === 1 /* ELEMENT_NODE */) {
        const options = getSpecOptions(input);
        serializeA = index_js$1.serializeNodeToHtml(input, {
            prettyHtml: true,
            outerHtml: true,
            removeHtmlComments: options.includeAnnotations === false,
            excludeTags: ['body'],
            serializeShadowRoot,
        });
    }
    else if (input.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
        serializeA = index_js$1.serializeNodeToHtml(input, {
            prettyHtml: true,
            excludeTags: ['style'],
            excludeTagContent: ['style'],
            serializeShadowRoot,
        });
    }
    else if (typeof input === 'string') {
        const parseA = index_js$1.parseHtmlToFragment(input);
        serializeA = index_js$1.serializeNodeToHtml(parseA, {
            prettyHtml: true,
            serializeShadowRoot,
        });
    }
    else {
        throw new Error(`expect toEqualHtml() value should be an element, shadow root or string.`);
    }
    const parseB = index_js$1.parseHtmlToFragment(shouldEqual);
    const serializeB = index_js$1.serializeNodeToHtml(parseB, {
        prettyHtml: true,
        excludeTags: ['body'],
    });
    if (serializeA !== serializeB) {
        expect(serializeA).toBe(serializeB);
        return {
            message: () => 'HTML does not match',
            pass: false,
        };
    }
    return {
        message: () => 'expect HTML to match',
        pass: true,
    };
}
function getSpecOptions(el) {
    if (el && el.ownerDocument && el.ownerDocument.defaultView) {
        return el.ownerDocument.defaultView['__stencil_spec_options'] || {};
    }
    return {};
}

function toEqualText(input, expectTextContent) {
    if (input == null) {
        throw new Error(`expect toEqualText() value is "${input}"`);
    }
    if (typeof input.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    let textContent;
    if (input.nodeType === 1 /* ELEMENT_NODE */) {
        textContent = input.textContent.replace(/\s\s+/g, ' ').trim();
    }
    else if (input != null) {
        textContent = String(input)
            .replace(/\s\s+/g, ' ')
            .trim();
    }
    if (typeof expectTextContent === 'string') {
        expectTextContent = expectTextContent.replace(/\s\s+/g, ' ').trim();
    }
    const pass = textContent === expectTextContent;
    return {
        message: () => `expected textContent "${expectTextContent}" to ${pass ? 'not ' : ''}equal "${textContent}"`,
        pass: pass,
    };
}

function toHaveClass(elm, expectClassName) {
    if (!elm) {
        throw new Error(`expect toHaveClass value is null`);
    }
    if (typeof elm.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    if (elm.nodeType !== 1) {
        throw new Error(`expect toHaveClass value is not an element`);
    }
    const pass = elm.classList.contains(expectClassName);
    return {
        message: () => `expected to ${pass ? 'not ' : ''}have css class "${expectClassName}"`,
        pass: pass,
    };
}
function toHaveClasses(elm, expectClassNames) {
    if (!elm) {
        throw new Error(`expect toHaveClasses value is null`);
    }
    if (typeof elm.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    if (elm.nodeType !== 1) {
        throw new Error(`expect toHaveClasses value is not an element`);
    }
    const pass = expectClassNames.every(expectClassName => {
        return elm.classList.contains(expectClassName);
    });
    return {
        message: () => `expected to ${pass ? 'not ' : ''}have css classes "${expectClassNames.join(' ')}", but className is "${elm.className}"`,
        pass: pass,
    };
}
function toMatchClasses(elm, expectClassNames) {
    let { pass } = toHaveClasses(elm, expectClassNames);
    if (pass) {
        pass = expectClassNames.length === elm.classList.length;
    }
    return {
        message: () => `expected to ${pass ? 'not ' : ''}match css classes "${expectClassNames.join(' ')}", but className is "${elm.className}"`,
        pass: pass,
    };
}

function toMatchScreenshot(compare, opts = {}) {
    if (!compare) {
        throw new Error(`expect toMatchScreenshot value is null`);
    }
    if (typeof compare.then === 'function') {
        throw new Error(`expect(compare).toMatchScreenshot() must be a resolved value, not a promise, before it can be tested`);
    }
    if (typeof compare.mismatchedPixels !== 'number') {
        throw new Error(`expect toMatchScreenshot() value is not a screenshot compare`);
    }
    const device = compare.device || compare.userAgent;
    if (typeof opts.allowableMismatchedRatio === 'number') {
        if (opts.allowableMismatchedRatio < 0 || opts.allowableMismatchedRatio > 1) {
            throw new Error(`expect toMatchScreenshot() allowableMismatchedRatio must be a value ranging from 0 to 1`);
        }
        const mismatchedRatio = compare.mismatchedPixels / (compare.width * compare.deviceScaleFactor * (compare.height * compare.deviceScaleFactor));
        return {
            message: () => `${device}: screenshot has a mismatch ratio of "${mismatchedRatio}" for "${compare.desc}", but expected ratio to be less than "${opts.allowableMismatchedRatio}"`,
            pass: mismatchedRatio <= opts.allowableMismatchedRatio,
        };
    }
    if (typeof opts.allowableMismatchedPixels === 'number') {
        if (opts.allowableMismatchedPixels < 0) {
            throw new Error(`expect toMatchScreenshot() allowableMismatchedPixels value must be a value that is 0 or greater`);
        }
        return {
            message: () => `${device}: screenshot has "${compare.mismatchedPixels}" mismatched pixels for "${compare.desc}", but expected less than "${opts.allowableMismatchedPixels}" mismatched pixels`,
            pass: compare.mismatchedPixels <= opts.allowableMismatchedPixels,
        };
    }
    if (typeof compare.allowableMismatchedRatio === 'number') {
        const mismatchedRatio = compare.mismatchedPixels / (compare.width * compare.deviceScaleFactor * (compare.height * compare.deviceScaleFactor));
        return {
            message: () => `${device}: screenshot has a mismatch ratio of "${mismatchedRatio}" for "${compare.desc}", but expected ratio to be less than "${compare.allowableMismatchedRatio}"`,
            pass: mismatchedRatio <= compare.allowableMismatchedRatio,
        };
    }
    if (typeof compare.allowableMismatchedPixels === 'number') {
        return {
            message: () => `${device}: screenshot has "${compare.mismatchedPixels}" mismatched pixels for "${compare.desc}", but expected less than "${compare.allowableMismatchedPixels}" mismatched pixels`,
            pass: compare.mismatchedPixels <= compare.allowableMismatchedPixels,
        };
    }
    throw new Error(`expect toMatchScreenshot() missing allowableMismatchedPixels in testing config`);
}

const expectExtend = {
    toEqualAttribute,
    toEqualAttributes,
    toEqualHtml,
    toEqualLightHtml,
    toEqualText,
    toHaveAttribute,
    toHaveClass,
    toHaveClasses,
    toMatchClasses,
    toHaveReceivedEvent,
    toHaveReceivedEventDetail,
    toHaveReceivedEventTimes,
    toHaveFirstReceivedEventDetail,
    toHaveNthReceivedEventDetail,
    toMatchScreenshot,
};

const mockedResponses = new Map();
function setupMockFetch(global) {
    const win = global.window;
    if (!('fetch' in win)) {
        win.fetch = function (input) {
            return globalMockFetch(input);
        };
    }
    if (!('fetch' in global)) {
        global.fetch = function (input) {
            return globalMockFetch(input);
        };
    }
}
async function globalMockFetch(requestInput) {
    let requestUrl;
    if (requestInput == null) {
        throw new Error(`missing url input for mock fetch()`);
    }
    else if (typeof requestInput === 'string') {
        requestUrl = requestInput;
    }
    else if (typeof requestInput.url === 'string') {
        requestUrl = requestInput.url;
    }
    else {
        throw new Error(`invalid url for mock fetch()`);
    }
    requestUrl = new url$1.URL(requestUrl, location.href).href;
    let mockedData = mockedResponses.get(requestUrl);
    if (mockedData == null) {
        const defaultUrl = new url$1.URL(FETCH_DEFAULT_PATH, location.href);
        mockedData = mockedResponses.get(defaultUrl.href);
    }
    if (mockedData == null) {
        return new MockResponse404();
    }
    const mockedResponse = mockedData.response.clone();
    if (typeof mockedResponse.status !== 'number') {
        mockedResponse.status = 200;
    }
    if (typeof mockedResponse.statusText !== 'string') {
        if (mockedResponse.status >= 500) {
            mockedResponse.statusText = 'Internal Server Error';
        }
        else if (mockedResponse.status === 404) {
            mockedResponse.statusText = 'Not Found';
        }
        else if (mockedResponse.status >= 400) {
            mockedResponse.statusText = 'Bad Request';
        }
        else if (mockedResponse.status === 302) {
            mockedResponse.statusText = 'Found';
        }
        else if (mockedResponse.status === 301) {
            mockedResponse.statusText = 'Moved Permanently';
        }
        else if (mockedResponse.status >= 300) {
            mockedResponse.statusText = 'Redirection';
        }
        else {
            mockedResponse.statusText = 'OK';
        }
    }
    mockedResponse.ok = mockedResponse.status >= 200 && mockedResponse.status <= 299;
    if (typeof mockedResponse.type !== 'string') {
        mockedResponse.type = 'basic';
    }
    return mockedResponse;
}
function setMockedResponse(response, input, reject) {
    if (!response) {
        throw new Error('MockResponse required');
    }
    if (typeof response.url !== 'string' || response.url === '') {
        if (typeof input === 'string') {
            response.url = input;
        }
        else if (input && typeof input.url === 'string') {
            response.url = input.url;
        }
        else {
            response.url = FETCH_DEFAULT_PATH;
        }
    }
    const u = new url$1.URL(response.url, location.href);
    response.url = u.href;
    const mockedResponseData = {
        response,
        reject,
    };
    mockedResponses.set(response.url, mockedResponseData);
}
function mockFetchReset() {
    mockedResponses.clear();
}
const mockFetch = {
    json(data, url) {
        const rsp = new index_js$1.MockResponse(JSON.stringify(data, null, 2), {
            headers: new index_js$1.MockHeaders({
                'Content-Type': 'application/json',
            }),
        });
        setMockedResponse(rsp, url, false);
    },
    text(data, url) {
        const rsp = new index_js$1.MockResponse(data, {
            headers: new index_js$1.MockHeaders({
                'Content-Type': 'text/plain',
            }),
        });
        setMockedResponse(rsp, url, false);
    },
    response(rsp, url) {
        setMockedResponse(rsp, url, false);
    },
    reject(rsp, url) {
        setMockedResponse(rsp, url, true);
    },
    reset: mockFetchReset,
};
class MockResponse404 extends index_js$1.MockResponse {
    constructor() {
        super('', {
            headers: new index_js$1.MockHeaders({
                'Content-Type': 'text/plain',
            }),
        });
        this.ok = false;
        this.status = 404;
        this.statusText = 'Not Found';
    }
    async json() {
        return { status: 404, statusText: 'Not Found' };
    }
    async text() {
        return 'Not Found';
    }
}
const FETCH_DEFAULT_PATH = '/mock-fetch-data';

const print = (val) => {
    return index_js$1.serializeNodeToHtml(val, {
        serializeShadowRoot: true,
        prettyHtml: true,
        outerHtml: true,
    });
};
const test = (val) => {
    return val !== undefined && val !== null && (val instanceof HTMLElement || val instanceof index_js$1.MockNode);
};
const HtmlSerializer = {
    print,
    test,
};

function resetBuildConditionals(b) {
    Object.keys(b).forEach(key => {
        b[key] = true;
    });
    b.isDev = true;
    b.isTesting = true;
    b.isDebug = false;
    b.lazyLoad = true;
    b.member = true;
    b.reflect = true;
    b.scoped = true;
    b.shadowDom = true;
    b.slotRelocation = true;
    b.asyncLoading = true;
    b.svg = true;
    b.updatable = true;
    b.vdomAttribute = true;
    b.vdomClass = true;
    b.vdomFunctional = true;
    b.vdomKey = true;
    b.vdomPropOrAttr = true;
    b.vdomRef = true;
    b.vdomListener = true;
    b.vdomStyle = true;
    b.vdomText = true;
    b.vdomXlink = true;
    b.allRenderFn = false;
    b.devTools = false;
    b.hydrateClientSide = false;
    b.hydrateServerSide = false;
    b.cssAnnotations = false;
    b.style = false;
    b.hydratedAttribute = false;
    b.hydratedClass = true;
    b.appendChildSlotFix = false;
    b.cloneNodeFix = false;
    b.dynamicImportShim = false;
    b.hotModuleReplacement = false;
    b.safari10 = false;
    b.scriptDataOpts = false;
    b.slotChildNodesFix = false;
}

function jestSetupTestFramework() {
    global.Context = {};
    global.resourcesUrl = '/build';
    expect.extend(expectExtend);
    expect.addSnapshotSerializer(HtmlSerializer);
    index_js$1.setupGlobal(global);
    setupMockFetch(global);
    beforeEach(() => {
        // reset the platform for this new test
        testing.resetPlatform();
        resetBuildConditionals(appData.BUILD);
        testing.modeResolutionChain.length = 0;
    });
    afterEach(async () => {
        if (global.__CLOSE_OPEN_PAGES__) {
            await global.__CLOSE_OPEN_PAGES__();
        }
        testing.stopAutoApplyChanges();
        index_js$1.teardownGlobal(global);
        global.Context = {};
        global.resourcesUrl = '/build';
    });
    const jasmineEnv = jasmine.getEnv();
    if (jasmineEnv != null) {
        jasmineEnv.addReporter({
            specStarted: (spec) => {
                global.currentSpec = spec;
            },
        });
    }
    global.screenshotDescriptions = new Set();
    const env = process.env;
    if (typeof env.__STENCIL_DEFAULT_TIMEOUT__ === 'string') {
        const time = parseInt(env.__STENCIL_DEFAULT_TIMEOUT__, 10);
        jest.setTimeout(time * 1.5);
        jasmine.DEFAULT_TIMEOUT_INTERVAL = time;
    }
}

/**
 * A new BuildCtx object is created for every build
 * and rebuild.
 */
class BuildContext {
    constructor(config, compilerCtx) {
        this.buildId = -1;
        this.buildMessages = [];
        this.buildResults = null;
        this.bundleBuildCount = 0;
        this.collections = [];
        this.completedTasks = [];
        this.components = [];
        this.componentGraph = new Map();
        this.data = {};
        this.diagnostics = [];
        this.dirsAdded = [];
        this.dirsDeleted = [];
        this.entryModules = [];
        this.filesAdded = [];
        this.filesChanged = [];
        this.filesDeleted = [];
        this.filesUpdated = [];
        this.filesWritten = [];
        this.globalStyle = undefined;
        this.hasConfigChanges = false;
        this.hasFinished = false;
        this.hasHtmlChanges = false;
        this.hasPrintedResults = false;
        this.hasServiceWorkerChanges = false;
        this.hasScriptChanges = true;
        this.hasStyleChanges = true;
        this.hydrateAppFilePath = null;
        this.indexBuildCount = 0;
        this.indexDoc = undefined;
        this.isRebuild = false;
        this.moduleFiles = [];
        this.outputs = [];
        this.packageJson = {};
        this.packageJsonFilePath = null;
        this.pendingCopyTasks = [];
        this.requiresFullBuild = true;
        this.scriptsAdded = [];
        this.scriptsDeleted = [];
        this.startTime = Date.now();
        this.styleBuildCount = 0;
        this.stylesPromise = null;
        this.stylesUpdated = [];
        this.timeSpan = null;
        this.transpileBuildCount = 0;
        this.config = config;
        this.compilerCtx = compilerCtx;
        this.buildId = ++this.compilerCtx.activeBuildId;
        this.debug = config.logger.debug.bind(config.logger);
    }
    start() {
        // get the build id from the incremented activeBuildId
        // print out a good message
        const msg = `${this.isRebuild ? 'rebuild' : 'build'}, ${this.config.fsNamespace}, ${this.config.devMode ? 'dev' : 'prod'} mode, started`;
        const buildLog = {
            buildId: this.buildId,
            messages: [],
            progress: 0,
        };
        this.compilerCtx.events.emit('buildLog', buildLog);
        // create a timespan for this build
        this.timeSpan = this.createTimeSpan(msg);
        // create a build timestamp for this build
        this.timestamp = getBuildTimestamp();
        // debug log our new build
        this.debug(`start build, ${this.timestamp}`);
        const buildStart = {
            buildId: this.buildId,
            timestamp: this.timestamp,
        };
        this.compilerCtx.events.emit('buildStart', buildStart);
    }
    createTimeSpan(msg, debug) {
        if (!this.hasFinished || debug) {
            if (debug) {
                if (this.config.watch) {
                    msg = `${this.config.logger.cyan('[' + this.buildId + ']')} ${msg}`;
                }
            }
            const timeSpan = this.config.logger.createTimeSpan(msg, debug, this.buildMessages);
            if (!debug && this.compilerCtx.events) {
                const buildLog = {
                    buildId: this.buildId,
                    messages: this.buildMessages,
                    progress: getProgress(this.completedTasks),
                };
                this.compilerCtx.events.emit('buildLog', buildLog);
            }
            return {
                duration: () => {
                    return timeSpan.duration();
                },
                finish: (finishedMsg, color, bold, newLineSuffix) => {
                    if (!this.hasFinished || debug) {
                        if (debug) {
                            if (this.config.watch) {
                                finishedMsg = `${this.config.logger.cyan('[' + this.buildId + ']')} ${finishedMsg}`;
                            }
                        }
                        timeSpan.finish(finishedMsg, color, bold, newLineSuffix);
                        if (!debug) {
                            const buildLog = {
                                buildId: this.buildId,
                                messages: this.buildMessages.slice(),
                                progress: getProgress(this.completedTasks),
                            };
                            this.compilerCtx.events.emit('buildLog', buildLog);
                        }
                    }
                    return timeSpan.duration();
                },
            };
        }
        return {
            duration() {
                return 0;
            },
            finish() {
                return 0;
            },
        };
    }
    debug(msg) {
        this.config.logger.debug(msg);
    }
    get hasError() {
        return hasError(this.diagnostics);
    }
    get hasWarning() {
        return hasWarning(this.diagnostics);
    }
    progress(t) {
        this.completedTasks.push(t);
    }
    async validateTypesBuild() {
        if (this.hasError) {
            // no need to wait on this one since
            // we already aborted this build
            return;
        }
        if (!this.validateTypesPromise) {
            // there is no pending validate types promise
            // so it probably already finished
            // so no need to wait on anything
            return;
        }
        if (!this.config.watch) {
            // this is not a watch build, so we need to make
            // sure that the type validation has finished
            this.debug(`build, non-watch, waiting on validateTypes`);
            await this.validateTypesPromise;
            this.debug(`build, non-watch, finished waiting on validateTypes`);
        }
    }
}
const getBuildTimestamp = () => {
    const d = new Date();
    // YYYY-MM-DDThh:mm:ss
    let timestamp = d.getUTCFullYear() + '-';
    timestamp += ('0' + (d.getUTCMonth() + 1)).slice(-2) + '-';
    timestamp += ('0' + d.getUTCDate()).slice(-2) + 'T';
    timestamp += ('0' + d.getUTCHours()).slice(-2) + ':';
    timestamp += ('0' + d.getUTCMinutes()).slice(-2) + ':';
    timestamp += ('0' + d.getUTCSeconds()).slice(-2);
    return timestamp;
};
const getProgress = (completedTasks) => {
    let progressIndex = 0;
    const taskKeys = Object.keys(ProgressTask);
    taskKeys.forEach((taskKey, index) => {
        if (completedTasks.includes(ProgressTask[taskKey])) {
            progressIndex = index;
        }
    });
    return (progressIndex + 1) / taskKeys.length;
};
const ProgressTask = {
    emptyOutputTargets: {},
    transpileApp: {},
    generateStyles: {},
    generateOutputTargets: {},
    validateTypesBuild: {},
    writeBuildFiles: {},
};

class Cache {
    constructor(config, cacheFs) {
        this.config = config;
        this.cacheFs = cacheFs;
        this.failed = 0;
        this.skip = false;
        this.sys = config.sys;
        this.logger = config.logger;
    }
    async initCacheDir() {
        if (this.config._isTesting) {
            return;
        }
        if (!this.config.enableCache || !this.cacheFs) {
            this.config.logger.info(`cache optimizations disabled`);
            this.clearDiskCache();
            return;
        }
        this.config.logger.debug(`cache enabled, cacheDir: ${this.config.cacheDir}`);
        try {
            const readmeFilePath = path$1.join(this.config.cacheDir, '_README.log');
            await this.cacheFs.writeFile(readmeFilePath, CACHE_DIR_README);
        }
        catch (e) {
            this.logger.error(`Cache, initCacheDir: ${e}`);
            this.config.enableCache = false;
        }
    }
    async get(key) {
        if (!this.config.enableCache || this.skip) {
            return null;
        }
        if (this.failed >= MAX_FAILED) {
            if (!this.skip) {
                this.skip = true;
                this.logger.debug(`cache had ${this.failed} failed ops, skip disk ops for remander of build`);
            }
            return null;
        }
        let result;
        try {
            result = await this.cacheFs.readFile(this.getCacheFilePath(key));
            this.failed = 0;
            this.skip = false;
        }
        catch (e) {
            this.failed++;
            result = null;
        }
        return result;
    }
    async put(key, value) {
        if (!this.config.enableCache) {
            return false;
        }
        let result;
        try {
            await this.cacheFs.writeFile(this.getCacheFilePath(key), value);
            result = true;
        }
        catch (e) {
            this.failed++;
            result = false;
        }
        return result;
    }
    async has(key) {
        const val = await this.get(key);
        return typeof val === 'string';
    }
    async createKey(domain, ...args) {
        if (!this.config.enableCache) {
            return domain + Math.random() * 9999999;
        }
        const hash = await this.sys.generateContentHash(JSON.stringify(args), 32);
        return domain + '_' + hash;
    }
    async commit() {
        if (this.config.enableCache) {
            this.skip = false;
            this.failed = 0;
            await this.cacheFs.commit();
            await this.clearExpiredCache();
        }
    }
    clear() {
        if (this.cacheFs != null) {
            this.cacheFs.clearCache();
        }
    }
    async clearExpiredCache() {
        if (this.cacheFs == null || this.sys.cacheStorage == null) {
            return;
        }
        const now = Date.now();
        const lastClear = (await this.sys.cacheStorage.get(EXP_STORAGE_KEY));
        if (lastClear != null) {
            const diff = now - lastClear;
            if (diff < ONE_DAY) {
                return;
            }
            const fs = this.cacheFs.sys;
            const cachedFileNames = await fs.readdir(this.config.cacheDir);
            const cachedFilePaths = cachedFileNames.map(f => path$1.join(this.config.cacheDir, f));
            let totalCleared = 0;
            const promises = cachedFilePaths.map(async (filePath) => {
                const stat = await fs.stat(filePath);
                const lastModified = stat.mtime.getTime();
                const diff = now - lastModified;
                if (diff > ONE_WEEK) {
                    await fs.unlink(filePath);
                    totalCleared++;
                }
            });
            await Promise.all(promises);
            this.logger.debug(`clearExpiredCache, cachedFileNames: ${cachedFileNames.length}, totalCleared: ${totalCleared}`);
        }
        this.logger.debug(`clearExpiredCache, set last clear`);
        await this.sys.cacheStorage.set(EXP_STORAGE_KEY, now);
    }
    async clearDiskCache() {
        if (this.cacheFs != null) {
            const hasAccess = await this.cacheFs.access(this.config.cacheDir);
            if (hasAccess) {
                await this.cacheFs.remove(this.config.cacheDir);
                await this.cacheFs.commit();
            }
        }
    }
    getCacheFilePath(key) {
        return path$1.join(this.config.cacheDir, key) + '.log';
    }
    getMemoryStats() {
        if (this.cacheFs != null) {
            return this.cacheFs.getMemoryStats();
        }
        return null;
    }
}
const MAX_FAILED = 100;
const ONE_DAY = 1000 * 60 * 60 * 24;
const ONE_WEEK = ONE_DAY * 7;
const EXP_STORAGE_KEY = `last_clear_expired_cache`;
const CACHE_DIR_README = `# Stencil Cache Directory

This directory contains files which the compiler has
cached for faster builds. To disable caching, please set
"enableCache: false" within the stencil config.

To change the cache directory, please update the
"cacheDir" property within the stencil config.
`;

const createInMemoryFs = (sys) => {
    const items = new Map();
    const outputTargetTypes = new Map();
    const accessData = async (filePath) => {
        const item = getItem(filePath);
        if (typeof item.exists === 'boolean') {
            return {
                exists: item.exists,
                isDirectory: item.isDirectory,
                isFile: item.isFile,
            };
        }
        const data = {
            exists: false,
            isDirectory: false,
            isFile: false,
        };
        const s = await stat(filePath);
        if (s) {
            item.exists = s.exists;
            item.isDirectory = s.isDirectory;
            item.isFile = s.isFile;
            data.exists = item.exists;
            data.isDirectory = item.isDirectory;
            data.isFile = item.isFile;
        }
        else {
            item.exists = false;
        }
        return data;
    };
    const access = async (filePath) => {
        const data = await accessData(filePath);
        return data.exists;
    };
    /**
     * Synchronous!!! Do not use!!!
     * (Only typescript transpiling is allowed to use)
     * @param filePath
     */
    const accessSync = (filePath) => {
        const item = getItem(filePath);
        if (typeof item.exists !== 'boolean') {
            const s = statSync(filePath);
            item.exists = s.exists;
            item.isDirectory = s.isDirectory;
            item.isFile = s.isFile;
        }
        return item.exists;
    };
    const copyFile = async (src, dest) => {
        const item = getItem(src);
        item.queueCopyFileToDest = dest;
    };
    const emptyDir = async (dirPath) => {
        const item = getItem(dirPath);
        await removeDir(dirPath);
        item.isFile = false;
        item.isDirectory = true;
        item.queueWriteToDisk = true;
        item.queueDeleteFromDisk = false;
    };
    const readdir = async (dirPath, opts = {}) => {
        dirPath = normalizePath(dirPath);
        const collectedPaths = [];
        if (opts.inMemoryOnly === true) {
            let inMemoryDir = dirPath;
            if (!inMemoryDir.endsWith('/')) {
                inMemoryDir += '/';
            }
            const inMemoryDirs = dirPath.split('/');
            items.forEach((d, filePath) => {
                if (!filePath.startsWith(dirPath)) {
                    return;
                }
                const parts = filePath.split('/');
                if (parts.length === inMemoryDirs.length + 1 || (opts.recursive && parts.length > inMemoryDirs.length)) {
                    if (d.exists) {
                        const item = {
                            absPath: filePath,
                            relPath: parts[inMemoryDirs.length],
                            isDirectory: d.isDirectory,
                            isFile: d.isFile,
                        };
                        if (!shouldExcludeFromReaddir(opts, item)) {
                            collectedPaths.push(item);
                        }
                    }
                }
            });
        }
        else {
            // always a disk read
            await readDirectory(dirPath, dirPath, opts, collectedPaths);
        }
        return collectedPaths.sort((a, b) => {
            if (a.absPath < b.absPath)
                return -1;
            if (a.absPath > b.absPath)
                return 1;
            return 0;
        });
    };
    const readDirectory = async (initPath, dirPath, opts, collectedPaths) => {
        // used internally only so we could easily recursively drill down
        // loop through this directory and sub directories
        // always a disk read!!
        const dirItems = await sys.readdir(dirPath);
        if (dirItems.length > 0) {
            // cache some facts about this path
            const item = getItem(dirPath);
            item.exists = true;
            item.isFile = false;
            item.isDirectory = true;
            await Promise.all(dirItems.map(async (dirItem) => {
                // let's loop through each of the files we've found so far
                // create an absolute path of the item inside of this directory
                const absPath = normalizePath(dirItem);
                const relPath = normalizePath(path$1.relative(initPath, absPath));
                // get the fs stats for the item, could be either a file or directory
                const stats = await stat(absPath);
                const childItem = {
                    absPath: absPath,
                    relPath: relPath,
                    isDirectory: stats.isDirectory,
                    isFile: stats.isFile,
                };
                if (shouldExcludeFromReaddir(opts, childItem)) {
                    return;
                }
                collectedPaths.push(childItem);
                if (opts.recursive === true && stats.isDirectory === true) {
                    // looks like it's yet another directory
                    // let's keep drilling down
                    await readDirectory(initPath, absPath, opts, collectedPaths);
                }
            }));
        }
    };
    const shouldExcludeFromReaddir = (opts, item) => {
        if (item.isDirectory) {
            if (Array.isArray(opts.excludeDirNames)) {
                const base = path$1.basename(item.absPath);
                if (opts.excludeDirNames.some(dir => base === dir)) {
                    return true;
                }
            }
        }
        else {
            if (Array.isArray(opts.excludeExtensions)) {
                const p = item.relPath.toLowerCase();
                if (opts.excludeExtensions.some(ext => p.endsWith(ext))) {
                    return true;
                }
            }
        }
        return false;
    };
    const readFile = async (filePath, opts) => {
        if (opts == null || opts.useCache === true || opts.useCache === undefined) {
            const item = getItem(filePath);
            if (item.exists && typeof item.fileText === 'string') {
                return item.fileText;
            }
        }
        const fileText = await sys.readFile(filePath);
        const item = getItem(filePath);
        if (typeof fileText === 'string') {
            if (fileText.length < MAX_TEXT_CACHE) {
                item.exists = true;
                item.isFile = true;
                item.isDirectory = false;
                item.fileText = fileText;
            }
        }
        else {
            item.exists = false;
        }
        return fileText;
    };
    /**
     * Synchronous!!! Do not use!!!
     * (Only typescript transpiling is allowed to use)
     * @param filePath
     */
    const readFileSync = (filePath, opts) => {
        if (opts == null || opts.useCache === true || opts.useCache === undefined) {
            const item = getItem(filePath);
            if (item.exists && typeof item.fileText === 'string') {
                return item.fileText;
            }
        }
        const fileText = sys.readFileSync(filePath);
        const item = getItem(filePath);
        if (typeof fileText === 'string') {
            if (fileText.length < MAX_TEXT_CACHE) {
                item.exists = true;
                item.isFile = true;
                item.isDirectory = false;
                item.fileText = fileText;
            }
        }
        else {
            item.exists = false;
        }
        return fileText;
    };
    const remove = async (itemPath) => {
        const stats = await stat(itemPath);
        if (stats.isDirectory === true) {
            await removeDir(itemPath);
        }
        else if (stats.isFile === true) {
            await removeItem(itemPath);
        }
    };
    const removeDir = async (dirPath) => {
        const item = getItem(dirPath);
        item.isFile = false;
        item.isDirectory = true;
        if (!item.queueWriteToDisk) {
            item.queueDeleteFromDisk = true;
        }
        try {
            const dirItems = await readdir(dirPath, { recursive: true });
            await Promise.all(dirItems.map(item => removeItem(item.absPath)));
        }
        catch (e) {
            // do not throw error if the directory never existed
        }
    };
    const removeItem = async (filePath) => {
        const item = getItem(filePath);
        if (!item.queueWriteToDisk) {
            item.queueDeleteFromDisk = true;
        }
    };
    const stat = async (itemPath) => {
        const item = getItem(itemPath);
        if (typeof item.isDirectory !== 'boolean' || typeof item.isFile !== 'boolean') {
            const s = await sys.stat(itemPath);
            if (s) {
                item.exists = true;
                if (s.isFile()) {
                    item.isFile = true;
                    item.isDirectory = false;
                    item.size = s.size;
                }
                else if (s.isDirectory()) {
                    item.isFile = false;
                    item.isDirectory = true;
                    item.size = s.size;
                }
                else {
                    item.isFile = false;
                    item.isDirectory = false;
                    item.size = null;
                }
            }
            else {
                item.exists = false;
            }
        }
        return {
            exists: !!item.exists,
            isFile: !!item.isFile,
            isDirectory: !!item.isDirectory,
            size: typeof item.size === 'number' ? item.size : 0,
        };
    };
    /**
     * Synchronous!!! Do not use!!!
     * Always returns an object, does not throw errors.
     * (Only typescript transpiling is allowed to use)
     * @param itemPath
     */
    const statSync = (itemPath) => {
        const item = getItem(itemPath);
        if (typeof item.isDirectory !== 'boolean' || typeof item.isFile !== 'boolean') {
            const s = sys.statSync(itemPath);
            if (s) {
                item.exists = true;
                if (s.isFile()) {
                    item.isFile = true;
                    item.isDirectory = false;
                    item.size = s.size;
                }
                else if (s.isDirectory()) {
                    item.isFile = false;
                    item.isDirectory = true;
                    item.size = s.size;
                }
                else {
                    item.isFile = false;
                    item.isDirectory = false;
                    item.size = null;
                }
            }
            else {
                item.exists = false;
            }
        }
        return {
            exists: !!item.exists,
            isFile: !!item.isFile,
            isDirectory: !!item.isDirectory,
        };
    };
    const writeFile = async (filePath, content, opts) => {
        if (typeof filePath !== 'string') {
            throw new Error(`writeFile, invalid filePath: ${filePath}`);
        }
        if (typeof content !== 'string') {
            throw new Error(`writeFile, invalid content: ${filePath}`);
        }
        const results = {
            ignored: false,
            changedContent: false,
            queuedWrite: false,
        };
        if (shouldIgnore(filePath) === true) {
            results.ignored = true;
            return results;
        }
        const item = getItem(filePath);
        item.exists = true;
        item.isFile = true;
        item.isDirectory = false;
        item.queueDeleteFromDisk = false;
        if (typeof item.fileText === 'string') {
            // compare strings but replace Windows CR to rule out any
            // insignificant new line differences
            results.changedContent = item.fileText.replace(/\r/g, '') !== content.replace(/\r/g, '');
        }
        else {
            results.changedContent = true;
        }
        item.fileText = content;
        results.queuedWrite = false;
        if (opts != null) {
            if (typeof opts.outputTargetType === 'string') {
                outputTargetTypes.set(filePath, opts.outputTargetType);
            }
            if (opts.useCache === false) {
                item.useCache = false;
            }
        }
        if (opts != null && opts.inMemoryOnly === true) {
            // we don't want to actually write this to disk
            // just keep it in memory
            if (item.queueWriteToDisk) {
                // we already queued this file to write to disk
                // in that case we still need to do it
                results.queuedWrite = true;
            }
            else {
                // we only want this in memory and
                // it wasn't already queued to be written
                item.queueWriteToDisk = false;
            }
            // ensure in-memory directories are created
            await ensureDir(filePath, true);
        }
        else if (opts != null && opts.immediateWrite === true) {
            // if this is an immediate write then write the file
            // now and do not add it to the queue
            if (results.changedContent || opts.useCache !== true) {
                // writing the file to disk is a big deal and kicks off fs watchers
                // so let's just double check that the file is actually different first
                const existingFile = await sys.readFile(filePath);
                if (typeof existingFile === 'string') {
                    results.changedContent = item.fileText.replace(/\r/g, '') !== existingFile.replace(/\r/g, '');
                }
                if (results.changedContent) {
                    await ensureDir(filePath, false);
                    await sys.writeFile(filePath, item.fileText);
                }
            }
        }
        else {
            // we want to write this to disk (eventually)
            // but only if the content is different
            // from our existing cached content
            if (!item.queueWriteToDisk && results.changedContent === true) {
                // not already queued to be written
                // and the content is different
                item.queueWriteToDisk = true;
                results.queuedWrite = true;
            }
        }
        return results;
    };
    const writeFiles = (files, opts) => {
        const writes = [];
        if (isIterable(files)) {
            files.forEach((content, filePath) => {
                writes.push(writeFile(filePath, content, opts));
            });
        }
        else {
            Object.keys(files).map(filePath => {
                writes.push(writeFile(filePath, files[filePath], opts));
            });
        }
        return Promise.all(writes);
    };
    const commit = async () => {
        const instructions = getCommitInstructions(items);
        // ensure directories we need exist
        const dirsAdded = await commitEnsureDirs(instructions.dirsToEnsure, false);
        // write all queued the files
        const filesWritten = await commitWriteFiles(instructions.filesToWrite);
        // write all queued the files to copy
        const filesCopied = await commitCopyFiles(instructions.filesToCopy);
        // remove all the queued files to be deleted
        const filesDeleted = await commitDeleteFiles(instructions.filesToDelete);
        // remove all the queued dirs to be deleted
        const dirsDeleted = await commitDeleteDirs(instructions.dirsToDelete);
        instructions.filesToDelete.forEach(clearFileCache);
        instructions.dirsToDelete.forEach(clearDirCache);
        // return only the files that were
        return {
            filesCopied,
            filesWritten,
            filesDeleted,
            dirsDeleted,
            dirsAdded,
        };
    };
    const ensureDir = async (p, inMemoryOnly) => {
        const allDirs = [];
        while (true) {
            p = path$1.dirname(p);
            if (typeof p === 'string' && p.length > 0 && p !== '/' && p.endsWith(':/') === false && p.endsWith(':\\') === false) {
                allDirs.push(p);
            }
            else {
                break;
            }
        }
        allDirs.reverse();
        await commitEnsureDirs(allDirs, inMemoryOnly);
    };
    const commitEnsureDirs = async (dirsToEnsure, inMemoryOnly) => {
        const dirsAdded = [];
        for (const dirPath of dirsToEnsure) {
            const item = getItem(dirPath);
            if (item.exists === true && item.isDirectory === true) {
                // already cached that this path is indeed an existing directory
                continue;
            }
            try {
                // cache that we know this is a directory on disk
                item.exists = true;
                item.isDirectory = true;
                item.isFile = false;
                if (!inMemoryOnly) {
                    await sys.mkdir(dirPath);
                }
                dirsAdded.push(dirPath);
            }
            catch (e) { }
        }
        return dirsAdded;
    };
    const commitCopyFiles = (filesToCopy) => {
        const copiedFiles = Promise.all(filesToCopy.map(async (data) => {
            const src = data[0];
            const dest = data[1];
            await sys.copyFile(src, dest);
            return [src, dest];
        }));
        return copiedFiles;
    };
    const commitWriteFiles = (filesToWrite) => {
        const writtenFiles = Promise.all(filesToWrite.map(async (filePath) => {
            if (typeof filePath !== 'string') {
                throw new Error(`unable to writeFile without filePath`);
            }
            return commitWriteFile(filePath);
        }));
        return writtenFiles;
    };
    const commitWriteFile = async (filePath) => {
        const item = getItem(filePath);
        if (item.fileText == null) {
            throw new Error(`unable to find item fileText to write: ${filePath}`);
        }
        await sys.writeFile(filePath, item.fileText);
        if (item.useCache === false) {
            clearFileCache(filePath);
        }
        return filePath;
    };
    const commitDeleteFiles = async (filesToDelete) => {
        const deletedFiles = await Promise.all(filesToDelete.map(async (filePath) => {
            if (typeof filePath !== 'string') {
                throw new Error(`unable to unlink without filePath`);
            }
            await sys.unlink(filePath);
            return filePath;
        }));
        return deletedFiles;
    };
    const commitDeleteDirs = async (dirsToDelete) => {
        const dirsDeleted = [];
        for (const dirPath of dirsToDelete) {
            await sys.rmdir(dirPath);
            dirsDeleted.push(dirPath);
        }
        return dirsDeleted;
    };
    const clearDirCache = (dirPath) => {
        dirPath = normalizePath(dirPath);
        items.forEach((_, f) => {
            const filePath = path$1.relative(dirPath, f).split('/')[0];
            if (!filePath.startsWith('.') && !filePath.startsWith('/')) {
                clearFileCache(f);
            }
        });
    };
    const clearFileCache = (filePath) => {
        filePath = normalizePath(filePath);
        const item = items.get(filePath);
        if (item != null && !item.queueWriteToDisk) {
            items.delete(filePath);
        }
    };
    const cancelDeleteFilesFromDisk = (filePaths) => {
        for (const filePath of filePaths) {
            const item = getItem(filePath);
            if (item.isFile === true && item.queueDeleteFromDisk === true) {
                item.queueDeleteFromDisk = false;
            }
        }
    };
    const cancelDeleteDirectoriesFromDisk = (dirPaths) => {
        for (const dirPath of dirPaths) {
            const item = getItem(dirPath);
            if (item.queueDeleteFromDisk === true) {
                item.queueDeleteFromDisk = false;
            }
        }
    };
    const getItem = (itemPath) => {
        itemPath = normalizePath(itemPath);
        let item = items.get(itemPath);
        if (item != null) {
            return item;
        }
        items.set(itemPath, (item = {
            exists: null,
            fileText: null,
            size: null,
            mtimeMs: null,
            isDirectory: null,
            isFile: null,
            queueCopyFileToDest: null,
            queueDeleteFromDisk: null,
            queueWriteToDisk: null,
            useCache: null,
        }));
        return item;
    };
    const clearCache = () => items.clear();
    const keys = () => Array.from(items.keys()).sort();
    const getMemoryStats = () => `data length: ${items.size}`;
    const getBuildOutputs = () => {
        const outputs = [];
        outputTargetTypes.forEach((outputTargetType, filePath) => {
            const output = outputs.find(o => o.type === outputTargetType);
            if (output) {
                output.files.push(filePath);
            }
            else {
                outputs.push({
                    type: outputTargetType,
                    files: [filePath],
                });
            }
        });
        outputs.forEach(o => o.files.sort());
        return outputs.sort((a, b) => {
            if (a.type < b.type)
                return -1;
            if (a.type > b.type)
                return 1;
            return 0;
        });
    };
    // only cache if it's less than 5MB-ish (using .length as a rough guess)
    // why 5MB? idk, seems like a good number for source text
    // it's pretty darn large to cover almost ALL legitimate source files
    // and anything larger is probably a REALLY large file and a rare case
    // which we don't need to eat up memory for
    const MAX_TEXT_CACHE = 5242880;
    const fs = {
        access,
        accessSync,
        accessData,
        cancelDeleteDirectoriesFromDisk,
        cancelDeleteFilesFromDisk,
        clearCache,
        clearDirCache,
        clearFileCache,
        commit,
        copyFile,
        emptyDir,
        getBuildOutputs,
        getItem,
        getMemoryStats,
        keys,
        readFile,
        readFileSync,
        readdir,
        remove,
        stat,
        statSync,
        sys,
        writeFile,
        writeFiles,
    };
    return fs;
};
const getCommitInstructions = (items) => {
    const instructions = {
        filesToDelete: [],
        filesToWrite: [],
        filesToCopy: [],
        dirsToDelete: [],
        dirsToEnsure: [],
    };
    items.forEach((item, itemPath) => {
        if (item.queueWriteToDisk === true) {
            if (item.isFile === true) {
                instructions.filesToWrite.push(itemPath);
                const dir = normalizePath(path$1.dirname(itemPath));
                if (!instructions.dirsToEnsure.includes(dir)) {
                    instructions.dirsToEnsure.push(dir);
                }
                const dirDeleteIndex = instructions.dirsToDelete.indexOf(dir);
                if (dirDeleteIndex > -1) {
                    instructions.dirsToDelete.splice(dirDeleteIndex, 1);
                }
                const fileDeleteIndex = instructions.filesToDelete.indexOf(itemPath);
                if (fileDeleteIndex > -1) {
                    instructions.filesToDelete.splice(fileDeleteIndex, 1);
                }
            }
            else if (item.isDirectory === true) {
                if (!instructions.dirsToEnsure.includes(itemPath)) {
                    instructions.dirsToEnsure.push(itemPath);
                }
                const dirDeleteIndex = instructions.dirsToDelete.indexOf(itemPath);
                if (dirDeleteIndex > -1) {
                    instructions.dirsToDelete.splice(dirDeleteIndex, 1);
                }
            }
        }
        else if (item.queueDeleteFromDisk === true) {
            if (item.isDirectory && !instructions.dirsToEnsure.includes(itemPath)) {
                instructions.dirsToDelete.push(itemPath);
            }
            else if (item.isFile && !instructions.filesToWrite.includes(itemPath)) {
                instructions.filesToDelete.push(itemPath);
            }
        }
        else if (typeof item.queueCopyFileToDest === 'string') {
            const src = itemPath;
            const dest = item.queueCopyFileToDest;
            instructions.filesToCopy.push([src, dest]);
            const dir = normalizePath(path$1.dirname(dest));
            if (!instructions.dirsToEnsure.includes(dir)) {
                instructions.dirsToEnsure.push(dir);
            }
            const dirDeleteIndex = instructions.dirsToDelete.indexOf(dir);
            if (dirDeleteIndex > -1) {
                instructions.dirsToDelete.splice(dirDeleteIndex, 1);
            }
            const fileDeleteIndex = instructions.filesToDelete.indexOf(dest);
            if (fileDeleteIndex > -1) {
                instructions.filesToDelete.splice(fileDeleteIndex, 1);
            }
        }
        item.queueDeleteFromDisk = false;
        item.queueWriteToDisk = false;
    });
    // add all the ancestor directories for each directory too
    for (let i = 0, ilen = instructions.dirsToEnsure.length; i < ilen; i++) {
        const segments = instructions.dirsToEnsure[i].split('/');
        for (let j = 2; j < segments.length; j++) {
            const dir = segments.slice(0, j).join('/');
            if (instructions.dirsToEnsure.includes(dir) === false) {
                instructions.dirsToEnsure.push(dir);
            }
        }
    }
    // sort directories so shortest paths are ensured first
    instructions.dirsToEnsure.sort((a, b) => {
        const segmentsA = a.split('/').length;
        const segmentsB = b.split('/').length;
        if (segmentsA < segmentsB)
            return -1;
        if (segmentsA > segmentsB)
            return 1;
        if (a.length < b.length)
            return -1;
        if (a.length > b.length)
            return 1;
        return 0;
    });
    // sort directories so longest paths are removed first
    instructions.dirsToDelete.sort((a, b) => {
        const segmentsA = a.split('/').length;
        const segmentsB = b.split('/').length;
        if (segmentsA < segmentsB)
            return 1;
        if (segmentsA > segmentsB)
            return -1;
        if (a.length < b.length)
            return 1;
        if (a.length > b.length)
            return -1;
        return 0;
    });
    for (const dirToEnsure of instructions.dirsToEnsure) {
        const i = instructions.dirsToDelete.indexOf(dirToEnsure);
        if (i > -1) {
            instructions.dirsToDelete.splice(i, 1);
        }
    }
    instructions.dirsToDelete = instructions.dirsToDelete.filter(dir => {
        if (dir === '/' || dir.endsWith(':/') === true) {
            return false;
        }
        return true;
    });
    instructions.dirsToEnsure = instructions.dirsToEnsure.filter(dir => {
        const item = items.get(dir);
        if (item != null && item.exists === true && item.isDirectory === true) {
            return false;
        }
        if (dir === '/' || dir.endsWith(':/')) {
            return false;
        }
        return true;
    });
    return instructions;
};
const shouldIgnore = (filePath) => {
    filePath = filePath.trim().toLowerCase();
    return IGNORE.some(ignoreFile => filePath.endsWith(ignoreFile));
};
const IGNORE = ['.ds_store', '.gitignore', 'desktop.ini', 'thumbs.db'];

const buildEvents = () => {
    const evCallbacks = [];
    const off = (callback) => {
        const index = evCallbacks.findIndex(ev => ev.callback === callback);
        if (index > -1) {
            evCallbacks.splice(index, 1);
            return true;
        }
        return false;
    };
    const on = (arg0, arg1) => {
        if (typeof arg0 === 'function') {
            const eventName = null;
            const callback = arg0;
            evCallbacks.push({
                eventName,
                callback,
            });
            return () => off(callback);
        }
        else if (typeof arg0 === 'string' && typeof arg1 === 'function') {
            const eventName = arg0.toLowerCase().trim();
            const callback = arg1;
            evCallbacks.push({
                eventName,
                callback,
            });
            return () => off(callback);
        }
        return () => false;
    };
    const emit = (eventName, data) => {
        const normalizedEventName = eventName.toLowerCase().trim();
        const callbacks = evCallbacks.slice();
        for (const ev of callbacks) {
            if (ev.eventName == null) {
                try {
                    ev.callback(eventName, data);
                }
                catch (e) {
                    console.error(e);
                }
            }
            else if (ev.eventName === normalizedEventName) {
                try {
                    ev.callback(data);
                }
                catch (e) {
                    console.error(e);
                }
            }
        }
    };
    const unsubscribeAll = () => {
        evCallbacks.length = 0;
    };
    return {
        emit,
        on,
        unsubscribeAll,
    };
};

const createWebWorkerMainController = (workerUrl, maxConcurrentWorkers) => {
    let msgIds = 0;
    let isDestroyed = false;
    let isQueued = false;
    let workerIds = 0;
    let workerBlob;
    const tasks = new Map();
    const queuedSendMsgs = [];
    const workers = [];
    const hardwareConcurrency = navigator.hardwareConcurrency || 1;
    const totalWorkers = Math.max(Math.min(maxConcurrentWorkers, hardwareConcurrency), 2) - 1;
    const tick = Promise.resolve();
    const onMsgsFromWorker = (worker, ev) => {
        if (!isDestroyed) {
            const msgsFromWorker = ev.data;
            if (Array.isArray(msgsFromWorker)) {
                for (const msgFromWorker of msgsFromWorker) {
                    if (msgFromWorker) {
                        const task = tasks.get(msgFromWorker.stencilId);
                        if (task) {
                            tasks.delete(msgFromWorker.stencilId);
                            if (msgFromWorker.stencilRtnError) {
                                task.reject(msgFromWorker.stencilRtnError);
                            }
                            else {
                                task.resolve(msgFromWorker.stencilRtnValue);
                            }
                            worker.activeTasks--;
                            if (worker.activeTasks < 0 || worker.activeTasks > 50) {
                                worker.activeTasks = 0;
                            }
                        }
                        else if (msgFromWorker.stencilRtnError) {
                            console.error(msgFromWorker.stencilRtnError);
                        }
                    }
                }
            }
        }
    };
    const onError = (e) => console.error(e);
    const createWebWorkerMain = () => {
        let worker = null;
        const workerOpts = {
            name: `stencil.worker.${workerIds++}`,
        };
        try {
            // first try directly starting the worker with the URL
            worker = new Worker(workerUrl, workerOpts);
        }
        catch (e) {
            // probably a cross-origin issue, try using a Blob instead
            if (workerBlob == null) {
                workerBlob = new Blob([`importScripts('${workerUrl}');`], { type: 'application/javascript' });
            }
            worker = new Worker(URL.createObjectURL(workerBlob), workerOpts);
        }
        const workerChild = {
            worker,
            activeTasks: 0,
            sendQueue: [],
        };
        worker.onerror = onError;
        worker.onmessage = ev => onMsgsFromWorker(workerChild, ev);
        return workerChild;
    };
    const sendMsgsToWorkers = (w) => {
        if (w.sendQueue.length > 0) {
            w.worker.postMessage(w.sendQueue);
            w.sendQueue.length = 0;
        }
    };
    const queueMsgToWorker = (msg) => {
        let theChoseOne;
        if (workers.length > 0) {
            theChoseOne = workers[0];
            if (totalWorkers > 1) {
                for (const worker of workers) {
                    if (worker.activeTasks < theChoseOne.activeTasks) {
                        theChoseOne = worker;
                    }
                }
                if (theChoseOne.activeTasks > 0 && workers.length < totalWorkers) {
                    theChoseOne = createWebWorkerMain();
                    workers.push(theChoseOne);
                }
            }
        }
        else {
            theChoseOne = createWebWorkerMain();
            workers.push(theChoseOne);
        }
        theChoseOne.activeTasks++;
        theChoseOne.sendQueue.push(msg);
    };
    const flushSendQueue = () => {
        isQueued = false;
        queuedSendMsgs.forEach(queueMsgToWorker);
        queuedSendMsgs.length = 0;
        workers.forEach(sendMsgsToWorkers);
    };
    const send = (...args) => new Promise((resolve, reject) => {
        if (isDestroyed) {
            reject(TASK_CANCELED_MSG);
        }
        else {
            const msg = {
                stencilId: msgIds++,
                args,
            };
            queuedSendMsgs.push(msg);
            tasks.set(msg.stencilId, {
                resolve,
                reject,
            });
            if (!isQueued) {
                isQueued = true;
                tick.then(flushSendQueue);
            }
        }
    });
    const destroy = () => {
        isDestroyed = true;
        tasks.forEach(t => t.reject(TASK_CANCELED_MSG));
        tasks.clear();
        workers.forEach(w => w.worker.terminate());
        workers.length = 0;
    };
    const handler = (name) => {
        return function (...args) {
            return send(name, ...args);
        };
    };
    return {
        send,
        destroy,
        handler,
    };
};

const COMMON_DIR_MODULE_EXTS = ['.tsx', '.ts', '.mjs', '.js', '.jsx', '.json', '.md'];
const COMMON_DIR_FILENAMES = ['package.json', 'index.js', 'index.mjs'];
const isDtsFile = (p) => p.endsWith('.d.ts');
const isTsFile = (p) => !isDtsFile(p) && p.endsWith('.ts');
const isTsxFile = (p) => p.endsWith('.tsx');
const getCommonDirName = (dirPath, fileName) => dirPath + '/' + fileName;
const isCommonDirModuleFile = (p) => COMMON_DIR_MODULE_EXTS.some(ext => p.endsWith(ext));
const setPackageVersion = (pkgVersions, pkgName, pkgVersion) => {
    pkgVersions.set(pkgName, pkgVersion);
};
const setPackageVersionByContent = (pkgVersions, pkgContent) => {
    try {
        const pkg = JSON.parse(pkgContent);
        if (pkg.name && pkg.version) {
            setPackageVersion(pkgVersions, pkg.name, pkg.version);
        }
    }
    catch (e) { }
};
const shouldFetchModule = (p) => IS_FETCH_ENV && !IS_NODE_ENV && isNodeModulePath(p);
const isNodeModulePath = (p) => normalizePath(p)
    .split('/')
    .includes('node_modules');
const getPackageDirPath = (p, moduleId) => {
    const parts = normalizePath(p).split('/');
    for (let i = parts.length - 1; i >= 1; i--) {
        if (parts[i - 1] === 'node_modules' && parts[i] === moduleId) {
            return parts.slice(0, i + 1).join('/');
        }
    }
    return null;
};

const httpFetch = (sys, input, init) => {
    if (sys && isFunction(sys.fetch)) {
        return sys.fetch(input, init);
    }
    return fetch(input, init);
};
const packageVersions = new Map();
const known404Urls = new Set();
const getRemoteModuleUrl = (sys, module) => {
    if (sys && isFunction(sys.getRemoteModuleUrl)) {
        return sys.getRemoteModuleUrl(module);
    }
    const nmBaseUrl = 'https://cdn.jsdelivr.net/npm/';
    const path = `${module.moduleId}${module.version ? '@' + module.version : ''}/${module.path}`;
    return new URL(path, nmBaseUrl).href;
};
const getStencilRootUrl = (compilerExe) => new URL('../', compilerExe).href;
const getStencilModuleUrl = (compilerExe, p) => {
    p = normalizePath(p);
    let parts = p.split('/');
    const nmIndex = parts.lastIndexOf('node_modules');
    if (nmIndex > -1 && nmIndex < parts.length - 1) {
        parts = parts.slice(nmIndex + 1);
        if (parts[0].startsWith('@')) {
            parts = parts.slice(2);
        }
        else {
            parts = parts.slice(1);
        }
        p = parts.join('/');
    }
    return new URL('./' + p, getStencilRootUrl(compilerExe)).href;
};
const getCommonDirUrl = (sys, pkgVersions, dirPath, fileName) => getNodeModuleFetchUrl(sys, pkgVersions, dirPath) + '/' + fileName;
const getNodeModuleFetchUrl = (sys, pkgVersions, filePath) => {
    // /node_modules/lodash/package.json
    filePath = normalizePath(filePath);
    // ["node_modules", "lodash", "package.json"]
    let pathParts = filePath.split('/').filter(p => p.length);
    const nmIndex = pathParts.lastIndexOf('node_modules');
    if (nmIndex > -1 && nmIndex < pathParts.length - 1) {
        pathParts = pathParts.slice(nmIndex + 1);
    }
    let moduleId = pathParts.shift();
    if (moduleId.startsWith('@')) {
        moduleId += '/' + pathParts.shift();
    }
    const path = pathParts.join('/');
    if (moduleId === '@stencil/core') {
        const compilerExe = sys.getCompilerExecutingPath();
        return getStencilModuleUrl(compilerExe, path);
    }
    return getRemoteModuleUrl(sys, {
        moduleId,
        version: pkgVersions.get(moduleId),
        path,
    });
};
const skipFilePathFetch = (filePath) => {
    if (isTsFile(filePath) || isTsxFile(filePath)) {
        // don't bother trying to resolve  node_module packages w/ typescript files
        // they should already be .js files
        return true;
    }
    const pathParts = filePath.split('/');
    const secondToLast = pathParts[pathParts.length - 2];
    const lastPart = pathParts[pathParts.length - 1];
    if (secondToLast === 'node_modules' && isCommonDirModuleFile(lastPart)) {
        // /node_modules/index.js
        // /node_modules/lodash.js
        // we just already know this is bogus, so don't bother
        return true;
    }
    return false;
};
const skipUrlFetch = (url) => 
// files we just already know not to try to resolve request
knownUrlSkips.some(knownSkip => url.endsWith(knownSkip));
const knownUrlSkips = [
    '/@stencil/core/internal.js',
    '/@stencil/core/internal.json',
    '/@stencil/core/internal.mjs',
    '/@stencil/core/internal/stencil-core.js/index.json',
    '/@stencil/core/internal/stencil-core.js.json',
    '/@stencil/core/internal/stencil-core.js/package.json',
    '/@stencil/core.js',
    '/@stencil/core.json',
    '/@stencil/core.mjs',
    '/@stencil/core.css',
    '/@stencil/core/index.js',
    '/@stencil/core/index.json',
    '/@stencil/core/index.mjs',
    '/@stencil/core/index.css',
    '/@stencil/package.json',
];

const writeFetchSuccessAsync = async (sys, inMemoryFs, url, filePath, content, pkgVersions) => {
    if (url.endsWith('package.json')) {
        setPackageVersionByContent(pkgVersions, content);
    }
    let dir = path$1.dirname(filePath);
    while (dir !== '/' && dir !== '') {
        if (inMemoryFs) {
            inMemoryFs.clearFileCache(dir);
            await inMemoryFs.sys.mkdir(dir);
        }
        else {
            await sys.mkdir(dir);
        }
        dir = path$1.dirname(dir);
    }
    if (inMemoryFs) {
        inMemoryFs.clearFileCache(filePath);
        await inMemoryFs.sys.writeFile(filePath, content);
    }
    else {
        await sys.writeFile(filePath, content);
    }
};

const fetchModuleAsync = async (sys, inMemoryFs, pkgVersions, url, filePath) => {
    if (skipFilePathFetch(filePath) || known404Urls.has(url) || skipUrlFetch(url)) {
        return undefined;
    }
    try {
        const rsp = await httpFetch(sys, url);
        if (rsp) {
            if (rsp.ok) {
                const content = await rsp.clone().text();
                await writeFetchSuccessAsync(sys, inMemoryFs, url, filePath, content, pkgVersions);
                return content;
            }
            if (rsp.status === 404) {
                known404Urls.add(url);
            }
        }
    }
    catch (e) {
        console.error(e);
    }
    return undefined;
};

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var caller = function () {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack; };
    var stack = (new Error()).stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
};

var pathParse = createCommonjsModule(function (module) {

var isWindows = process.platform === 'win32';

// Regex to split a windows path into three parts: [*, device, slash,
// tail] windows-only
var splitDeviceRe =
    /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

// Regex to split the tail part of the above into [*, dir, basename, ext]
var splitTailRe =
    /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

var win32 = {};

// Function to split a filename into [root, dir, basename, ext]
function win32SplitPath(filename) {
  // Separate device+slash from tail
  var result = splitDeviceRe.exec(filename),
      device = (result[1] || '') + (result[2] || ''),
      tail = result[3] || '';
  // Split the tail into dir, basename and extension
  var result2 = splitTailRe.exec(tail),
      dir = result2[1],
      basename = result2[2],
      ext = result2[3];
  return [device, dir, basename, ext];
}

win32.parse = function(pathString) {
  if (typeof pathString !== 'string') {
    throw new TypeError(
        "Parameter 'pathString' must be a string, not " + typeof pathString
    );
  }
  var allParts = win32SplitPath(pathString);
  if (!allParts || allParts.length !== 4) {
    throw new TypeError("Invalid path '" + pathString + "'");
  }
  return {
    root: allParts[0],
    dir: allParts[0] + allParts[1].slice(0, -1),
    base: allParts[2],
    ext: allParts[3],
    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
  };
};



// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var posix = {};


function posixSplitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
}


posix.parse = function(pathString) {
  if (typeof pathString !== 'string') {
    throw new TypeError(
        "Parameter 'pathString' must be a string, not " + typeof pathString
    );
  }
  var allParts = posixSplitPath(pathString);
  if (!allParts || allParts.length !== 4) {
    throw new TypeError("Invalid path '" + pathString + "'");
  }
  allParts[1] = allParts[1] || '';
  allParts[2] = allParts[2] || '';
  allParts[3] = allParts[3] || '';

  return {
    root: allParts[0],
    dir: allParts[0] + allParts[1].slice(0, -1),
    base: allParts[2],
    ext: allParts[3],
    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
  };
};


if (isWindows)
  module.exports = win32.parse;
else /* posix */
  module.exports = posix.parse;

module.exports.posix = posix.parse;
module.exports.win32 = win32.parse;
});
var pathParse_1 = pathParse.posix;
var pathParse_2 = pathParse.win32;

var parse = path$1__default.parse || pathParse;

var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = '/';
    if ((/^([A-Za-z]:)/).test(absoluteStart)) {
        prefix = '';
    } else if ((/^\\\\/).test(absoluteStart)) {
        prefix = '\\\\';
    }

    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
    }

    return paths.reduce(function (dirs, aPath) {
        return dirs.concat(modules.map(function (moduleDir) {
            return path$1__default.resolve(prefix, aPath, moduleDir);
        }));
    }, []);
};

var nodeModulesPaths = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory
        ? [].concat(opts.moduleDirectory)
        : ['node_modules'];

    if (opts && typeof opts.paths === 'function') {
        return opts.paths(
            request,
            start,
            function () { return getNodeModulesDirs(start, modules); },
            opts
        );
    }

    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};

var normalizeOptions = function (x, opts) {
    /**
     * This file is purposefully a passthrough. It's expected that third-party
     * environments will override it at runtime in order to inject special logic
     * into `resolve` (by manipulating the options). One such example is the PnP
     * code path in Yarn.
     */

    return opts || {};
};

const assert = true;
const async_hooks = ">= 8";
const buffer_ieee754 = "< 0.9.7";
const buffer = true;
const child_process = true;
const cluster = true;
const console$1 = true;
const constants = true;
const crypto$1 = true;
const _debug_agent = ">= 1 && < 8";
const _debugger = "< 8";
const dgram = true;
const dns = true;
const domain = true;
const events = true;
const freelist = "< 6";
const fs = true;
const _http_agent = ">= 0.11.1";
const _http_client = ">= 0.11.1";
const _http_common = ">= 0.11.1";
const _http_incoming = ">= 0.11.1";
const _http_outgoing = ">= 0.11.1";
const _http_server = ">= 0.11.1";
const http = true;
const http2 = ">= 8.8";
const https = true;
const inspector = ">= 8.0.0";
const _linklist = "< 8";
const module$1 = true;
const net = true;
const os = true;
const path = true;
const perf_hooks = ">= 8.5";
const process$1 = ">= 1";
const punycode = true;
const querystring = true;
const readline = true;
const repl = true;
const smalloc = ">= 0.11.5 && < 3";
const _stream_duplex = ">= 0.9.4";
const _stream_transform = ">= 0.9.4";
const _stream_wrap = ">= 1.4.1";
const _stream_passthrough = ">= 0.9.4";
const _stream_readable = ">= 0.9.4";
const _stream_writable = ">= 0.9.4";
const stream = true;
const string_decoder = true;
const sys = true;
const timers = true;
const _tls_common = ">= 0.11.13";
const _tls_legacy = ">= 0.11.3 && < 10";
const _tls_wrap = ">= 0.11.3";
const tls = true;
const trace_events = ">= 10";
const tty = true;
const url = true;
const util = true;
const v8 = ">= 1";
const vm = true;
const worker_threads = ">= 11.7";
const zlib = true;
const core = {
	assert: assert,
	async_hooks: async_hooks,
	buffer_ieee754: buffer_ieee754,
	buffer: buffer,
	child_process: child_process,
	cluster: cluster,
	console: console$1,
	constants: constants,
	crypto: crypto$1,
	_debug_agent: _debug_agent,
	_debugger: _debugger,
	dgram: dgram,
	dns: dns,
	domain: domain,
	events: events,
	freelist: freelist,
	fs: fs,
	"fs/promises": ">= 10 && < 10.1",
	_http_agent: _http_agent,
	_http_client: _http_client,
	_http_common: _http_common,
	_http_incoming: _http_incoming,
	_http_outgoing: _http_outgoing,
	_http_server: _http_server,
	http: http,
	http2: http2,
	https: https,
	inspector: inspector,
	_linklist: _linklist,
	module: module$1,
	net: net,
	"node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
	"node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
	"node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
	os: os,
	path: path,
	perf_hooks: perf_hooks,
	process: process$1,
	punycode: punycode,
	querystring: querystring,
	readline: readline,
	repl: repl,
	smalloc: smalloc,
	_stream_duplex: _stream_duplex,
	_stream_transform: _stream_transform,
	_stream_wrap: _stream_wrap,
	_stream_passthrough: _stream_passthrough,
	_stream_readable: _stream_readable,
	_stream_writable: _stream_writable,
	stream: stream,
	string_decoder: string_decoder,
	sys: sys,
	timers: timers,
	_tls_common: _tls_common,
	_tls_legacy: _tls_legacy,
	_tls_wrap: _tls_wrap,
	tls: tls,
	trace_events: trace_events,
	tty: tty,
	url: url,
	util: util,
	"v8/tools/arguments": ">= 10 && < 12",
	"v8/tools/codemap": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/consarray": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/csvparser": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/logreader": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/profile_view": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	"v8/tools/splaytree": [
	">= 4.4.0 && < 5",
	">= 5.2.0 && < 12"
],
	v8: v8,
	vm: vm,
	worker_threads: worker_threads,
	zlib: zlib
};

const core$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    assert: assert,
    async_hooks: async_hooks,
    buffer_ieee754: buffer_ieee754,
    buffer: buffer,
    child_process: child_process,
    cluster: cluster,
    console: console$1,
    constants: constants,
    crypto: crypto$1,
    _debug_agent: _debug_agent,
    _debugger: _debugger,
    dgram: dgram,
    dns: dns,
    domain: domain,
    events: events,
    freelist: freelist,
    fs: fs,
    _http_agent: _http_agent,
    _http_client: _http_client,
    _http_common: _http_common,
    _http_incoming: _http_incoming,
    _http_outgoing: _http_outgoing,
    _http_server: _http_server,
    http: http,
    http2: http2,
    https: https,
    inspector: inspector,
    _linklist: _linklist,
    module: module$1,
    net: net,
    os: os,
    path: path,
    perf_hooks: perf_hooks,
    process: process$1,
    punycode: punycode,
    querystring: querystring,
    readline: readline,
    repl: repl,
    smalloc: smalloc,
    _stream_duplex: _stream_duplex,
    _stream_transform: _stream_transform,
    _stream_wrap: _stream_wrap,
    _stream_passthrough: _stream_passthrough,
    _stream_readable: _stream_readable,
    _stream_writable: _stream_writable,
    stream: stream,
    string_decoder: string_decoder,
    sys: sys,
    timers: timers,
    _tls_common: _tls_common,
    _tls_legacy: _tls_legacy,
    _tls_wrap: _tls_wrap,
    tls: tls,
    trace_events: trace_events,
    tty: tty,
    url: url,
    util: util,
    v8: v8,
    vm: vm,
    worker_threads: worker_threads,
    zlib: zlib,
    'default': core
});

const data = getCjsExportFromNamespace(core$1);

var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

function specifierIncluded(specifier) {
    var parts = specifier.split(' ');
    var op = parts.length > 1 ? parts[0] : '=';
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

    for (var i = 0; i < 3; ++i) {
        var cur = Number(current[i] || 0);
        var ver = Number(versionParts[i] || 0);
        if (cur === ver) {
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        }
        if (op === '<') {
            return cur < ver;
        } else if (op === '>=') {
            return cur >= ver;
        } else {
            return false;
        }
    }
    return op === '>=';
}

function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) { return false; }
    for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) { return false; }
    }
    return true;
}

function versionIncluded(specifierValue) {
    if (typeof specifierValue === 'boolean') { return specifierValue; }
    if (specifierValue && typeof specifierValue === 'object') {
        for (var i = 0; i < specifierValue.length; ++i) {
            if (matchesRange(specifierValue[i])) { return true; }
        }
        return false;
    }
    return matchesRange(specifierValue);
}



var core$2 = {};
for (var mod in data) { // eslint-disable-line no-restricted-syntax
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core$2[mod] = versionIncluded(data[mod]);
    }
}
var core_1 = core$2;

var isCore = function isCore(x) {
    return Object.prototype.hasOwnProperty.call(core_1, x);
};

var defaultIsFile = function isFile(file, cb) {
    fs$1.stat(file, function (err, stat) {
        if (!err) {
            return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultIsDir = function isDirectory(dir, cb) {
    fs$1.stat(dir, function (err, stat) {
        if (!err) {
            return cb(null, stat.isDirectory());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var maybeUnwrapSymlink = function maybeUnwrapSymlink(x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
        fs$1.realpath(x, function (realPathErr, realPath) {
            if (realPathErr && realPathErr.code !== 'ENOENT') cb(realPathErr);
            else cb(null, realPathErr ? x : realPath);
        });
    } else {
        cb(null, x);
    }
};

var async = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === 'function') {
        cb = opts;
        opts = {};
    }
    if (typeof x !== 'string') {
        var err = new TypeError('Path must be a string.');
        return process.nextTick(function () {
            cb(err);
        });
    }

    opts = normalizeOptions(x, opts);

    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs$1.readFile;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path$1__default.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path$1__default.resolve(basedir);

    maybeUnwrapSymlink(
        absoluteStart,
        opts,
        function (err, realStart) {
            if (err) cb(err);
            else init(realStart);
        }
    );

    var res;
    function init(basedir) {
        if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
            res = path$1__default.resolve(basedir, x);
            if (x === '..' || x.slice(-1) === '/') res += '/';
            if ((/\/$/).test(x) && res === basedir) {
                loadAsDirectory(res, opts.package, onfile);
            } else loadAsFile(res, opts.package, onfile);
        } else loadNodeModules(x, basedir, function (err, n, pkg) {
            if (err) cb(err);
            else if (isCore(x)) return cb(null, x);
            else if (n) {
                return maybeUnwrapSymlink(n, opts, function (err, realN) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realN, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function onfile(err, m, pkg) {
        if (err) cb(err);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function (err, d, pkg) {
            if (err) cb(err);
            else if (d) {
                maybeUnwrapSymlink(d, opts, function (err, realD) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realD, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function loadAsFile(x, thePackage, callback) {
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === 'function') {
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
        }

        var exts = [''].concat(extensions);
        load(exts, x, loadAsFilePackage);

        function load(exts, x, loadPackage) {
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];

            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path$1__default.dirname(file), onpkg);

            function onpkg(err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path$1__default.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load(
                        [''].concat(extensions.slice()),
                        path$1__default.resolve(dir, r),
                        pkg
                    );
                }
                isFile(file, onex);
            }
            function onex(err, ex) {
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
            }
        }
    }

    function loadpkg(dir, cb) {
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return cb(null);
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

        maybeUnwrapSymlink(dir, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path$1__default.dirname(dir), cb);
            var pkgfile = path$1__default.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(path$1__default.dirname(dir), cb);

                readFile(pkgfile, function (err, body) {
                    if (err) cb(err);
                    try { var pkg = JSON.parse(body); } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }
                    cb(null, pkg, dir);
                });
            });
        });
    }

    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === 'function') {
            cb = fpkg;
            fpkg = opts.package;
        }

        maybeUnwrapSymlink(x, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path$1__default.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                if (err) return cb(err);
                if (!ex) return loadAsFile(path$1__default.join(x, 'index'), fpkg, cb);

                readFile(pkgfile, function (err, body) {
                    if (err) return cb(err);
                    try {
                        var pkg = JSON.parse(body);
                    } catch (jsonErr) {}

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }

                    if (pkg && pkg.main) {
                        if (typeof pkg.main !== 'string') {
                            var mainError = new TypeError('package â€œ' + pkg.name + 'â€ `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            return cb(mainError);
                        }
                        if (pkg.main === '.' || pkg.main === './') {
                            pkg.main = 'index';
                        }
                        loadAsFile(path$1__default.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path$1__default.join(x, 'index'), pkg, cb);

                            var dir = path$1__default.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path$1__default.join(x, 'index'), pkg, cb);
                            });
                        });
                        return;
                    }

                    loadAsFile(path$1__default.join(x, '/index'), pkg, cb);
                });
            });
        });
    }

    function processDirs(cb, dirs) {
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];

        isDirectory(dir, isdir);

        function isdir(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            var file = path$1__default.join(dir, x);
            loadAsFile(file, opts.package, onfile);
        }

        function onfile(err, m, pkg) {
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(path$1__default.join(dir, x), opts.package, ondir);
        }

        function ondir(err, n, pkg) {
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
        }
    }
    function loadNodeModules(x, start, cb) {
        processDirs(cb, nodeModulesPaths(start, opts, x));
    }
};

var defaultIsFile$1 = function isFile(file) {
    try {
        var stat = fs$1.statSync(file);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isFile() || stat.isFIFO();
};

var defaultIsDir$1 = function isDirectory(dir) {
    try {
        var stat = fs$1.statSync(dir);
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return stat.isDirectory();
};

var maybeUnwrapSymlink$1 = function maybeUnwrapSymlink(x, opts) {
    if (opts && opts.preserveSymlinks === false) {
        try {
            return fs$1.realpathSync(x);
        } catch (realPathErr) {
            if (realPathErr.code !== 'ENOENT') {
                throw realPathErr;
            }
        }
    }
    return x;
};

var sync = function (x, options) {
    if (typeof x !== 'string') {
        throw new TypeError('Path must be a string.');
    }
    var opts = normalizeOptions(x, options);

    var isFile = opts.isFile || defaultIsFile$1;
    var readFileSync = opts.readFileSync || fs$1.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir$1;

    var extensions = opts.extensions || ['.js'];
    var basedir = opts.basedir || path$1__default.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || [];

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeUnwrapSymlink$1(path$1__default.resolve(basedir), opts);

    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
        var res = path$1__default.resolve(absoluteStart, x);
        if (x === '..' || x.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeUnwrapSymlink$1(m, opts);
    } else if (isCore(x)) {
        return x;
    } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeUnwrapSymlink$1(n, opts);
    }

    if (isCore(x)) return x;

    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(x) {
        var pkg = loadpkg(path$1__default.dirname(x));

        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path$1__default.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) {
                x = path$1__default.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
            }
        }

        if (isFile(x)) {
            return x;
        }

        for (var i = 0; i < extensions.length; i++) {
            var file = x + extensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }

    function loadpkg(dir) {
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return;
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

        var pkgfile = path$1__default.join(maybeUnwrapSymlink$1(dir, opts), 'package.json');

        if (!isFile(pkgfile)) {
            return loadpkg(path$1__default.dirname(dir));
        }

        var body = readFileSync(pkgfile);

        try {
            var pkg = JSON.parse(body);
        } catch (jsonErr) {}

        if (pkg && opts.packageFilter) {
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        }

        return { pkg: pkg, dir: dir };
    }

    function loadAsDirectorySync(x) {
        var pkgfile = path$1__default.join(maybeUnwrapSymlink$1(x, opts), '/package.json');
        if (isFile(pkgfile)) {
            try {
                var body = readFileSync(pkgfile, 'UTF8');
                var pkg = JSON.parse(body);
            } catch (e) {}

            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
            }

            if (pkg && pkg.main) {
                if (typeof pkg.main !== 'string') {
                    var mainError = new TypeError('package â€œ' + pkg.name + 'â€ `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
                }
                if (pkg.main === '.' || pkg.main === './') {
                    pkg.main = 'index';
                }
                try {
                    var m = loadAsFileSync(path$1__default.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path$1__default.resolve(x, pkg.main));
                    if (n) return n;
                } catch (e) {}
            }
        }

        return loadAsFileSync(path$1__default.join(x, '/index'));
    }

    function loadNodeModulesSync(x, start) {
        var dirs = nodeModulesPaths(start, opts, x);
        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            if (isDirectory(dir)) {
                var m = loadAsFileSync(path$1__default.join(dir, '/', x));
                if (m) return m;
                var n = loadAsDirectorySync(path$1__default.join(dir, '/', x));
                if (n) return n;
            }
        }
    }
};

var resolve = createCommonjsModule(function (module, exports) {
async.core = core_1;
async.isCore = isCore;
async.sync = sync;
module.exports = async;
});

const resolveModuleIdAsync = (sys, inMemoryFs, opts) => {
    const resolverOpts = createCustomResolverAsync(sys, inMemoryFs, opts.exts);
    resolverOpts.basedir = path$1.dirname(opts.containingFile);
    if (opts.packageFilter) {
        resolverOpts.packageFilter = opts.packageFilter;
    }
    else if (opts.packageFilter !== null) {
        resolverOpts.packageFilter = pkg => {
            if (!isString(pkg.main) || pkg.main === '') {
                pkg.main = 'package.json';
            }
            return pkg;
        };
    }
    return new Promise((resolvePromise, rejectPromise) => {
        resolve(opts.moduleId, resolverOpts, (err, resolveId, pkgData) => {
            if (err) {
                rejectPromise(err);
            }
            else {
                resolveId = normalizePath(resolveId);
                const results = {
                    moduleId: opts.moduleId,
                    resolveId,
                    pkgData,
                    pkgDirPath: getPackageDirPath(resolveId, opts.moduleId),
                };
                resolvePromise(results);
            }
        });
    });
};
const createCustomResolverAsync = (sys, inMemoryFs, exts) => {
    return {
        async isFile(filePath, cb) {
            const fsFilePath = normalizeFsPath(filePath);
            const stat = await inMemoryFs.stat(fsFilePath);
            if (stat.isFile) {
                cb(null, true);
                return;
            }
            if (shouldFetchModule(fsFilePath)) {
                const endsWithExt = exts.some(ext => fsFilePath.endsWith(ext));
                if (endsWithExt) {
                    const url = getNodeModuleFetchUrl(sys, packageVersions, fsFilePath);
                    const content = await fetchModuleAsync(sys, inMemoryFs, packageVersions, url, fsFilePath);
                    const checkFileExists = typeof content === 'string';
                    cb(null, checkFileExists);
                    return;
                }
            }
            cb(null, false);
        },
        async isDirectory(dirPath, cb) {
            const fsDirPath = normalizeFsPath(dirPath);
            const stat = await inMemoryFs.stat(fsDirPath);
            if (stat.isDirectory) {
                cb(null, true);
                return;
            }
            if (shouldFetchModule(fsDirPath)) {
                if (path$1.basename(fsDirPath) === 'node_modules') {
                    // just the /node_modules directory
                    inMemoryFs.sys.mkdirSync(fsDirPath);
                    inMemoryFs.clearFileCache(fsDirPath);
                    cb(null, true);
                    return;
                }
                if (isCommonDirModuleFile(fsDirPath)) {
                    // don't bother seeing if it's a directory if it has a common file extension
                    cb(null, false);
                    return;
                }
                for (const fileName of COMMON_DIR_FILENAMES) {
                    const url = getCommonDirUrl(sys, packageVersions, fsDirPath, fileName);
                    const filePath = getCommonDirName(fsDirPath, fileName);
                    const content = await fetchModuleAsync(sys, inMemoryFs, packageVersions, url, filePath);
                    if (isString(content)) {
                        cb(null, true);
                        return;
                    }
                }
            }
            cb(null, false);
        },
        async readFile(p, cb) {
            const fsFilePath = normalizeFsPath(p);
            const data = await inMemoryFs.readFile(fsFilePath);
            if (isString(data)) {
                return cb(null, data);
            }
            return cb(`readFile not found: ${p}`, undefined);
        },
        extensions: exts,
    };
};

const createSystem = () => {
    const items = new Map();
    const destroys = new Set();
    const addDestory = (cb) => destroys.add(cb);
    const removeDestory = (cb) => destroys.delete(cb);
    const events = buildEvents();
    const destroy = async () => {
        const waits = [];
        destroys.forEach(cb => {
            try {
                const rtn = cb();
                if (rtn && rtn.then) {
                    waits.push(rtn);
                }
            }
            catch (e) {
                console.error(`stencil sys destroy: ${e}`);
            }
        });
        await Promise.all(waits);
        destroys.clear();
    };
    const normalize = (p) => {
        if (p === '/' || p === '') {
            return '/';
        }
        const dir = path$1.dirname(p);
        const base = path$1.basename(p);
        if (dir.endsWith('/')) {
            return normalizePath(`${dir}${base}`);
        }
        return normalizePath(`${dir}/${base}`);
    };
    const accessSync = (p) => {
        const item = items.get(normalize(p));
        return !!(item && (item.isDirectory || item.isFile));
    };
    const access = async (p) => accessSync(p);
    const copyFile = async (src, dest) => {
        writeFileSync(dest, readFileSync(src));
        return true;
    };
    const encodeToBase64 = (str) => btoa(unescape(encodeURIComponent(str)));
    const getCurrentDirectory = () => {
        if (IS_NODE_ENV) {
            return global['process'].cwd();
        }
        return '/';
    };
    const getCompilerExecutingPath = () => {
        if (IS_NODE_ENV) {
            return __filename;
        }
        if (IS_WEB_WORKER_ENV) {
            return location.href;
        }
        throw new Error('unable to find executing path');
    };
    const isSymbolicLink = async (_p) => false;
    const mkdirSync = (p, opts) => {
        p = normalize(p);
        const results = {
            basename: path$1.basename(p),
            dirname: path$1.dirname(p),
            path: p,
            newDirs: [],
            error: null,
        };
        mkdirRecursiveSync(p, opts, results);
        return results;
    };
    const mkdirRecursiveSync = (p, opts, results) => {
        const parentDir = path$1.dirname(p);
        if (opts && opts.recursive && !isRootPath(parentDir)) {
            mkdirRecursiveSync(parentDir, opts, results);
        }
        const item = items.get(p);
        if (!item) {
            items.set(p, {
                basename: path$1.basename(p),
                dirname: parentDir,
                isDirectory: true,
                isFile: false,
                watcherCallbacks: null,
                data: undefined,
            });
            results.newDirs.push(p);
            emitDirectoryWatch(p, new Set());
        }
        else {
            item.isDirectory = true;
            item.isFile = false;
        }
    };
    const mkdir = async (p, opts) => mkdirSync(p, opts);
    const readdirSync = (p) => {
        p = normalize(p);
        const dirItems = [];
        const dir = items.get(p);
        if (dir && dir.isDirectory) {
            items.forEach((item, itemPath) => {
                if (itemPath !== '/') {
                    if (p.endsWith('/') && `${p}${item.basename}` === itemPath) {
                        dirItems.push(itemPath);
                    }
                    else if (`${p}/${item.basename}` === itemPath) {
                        dirItems.push(itemPath);
                    }
                }
            });
        }
        return dirItems.sort();
    };
    const readdir = async (p) => readdirSync(p);
    const readFileSync = (p) => {
        p = normalize(p);
        const item = items.get(p);
        if (item && item.isFile) {
            return item.data;
        }
        return undefined;
    };
    const readFile = async (p) => readFileSync(p);
    const realpathSync = (p) => normalize(p);
    const realpath = async (p) => realpathSync(p);
    const rename = async (oldPath, newPath) => {
        oldPath = normalizePath(oldPath);
        newPath = normalizePath(newPath);
        const results = {
            oldPath,
            newPath,
            renamed: [],
            oldDirs: [],
            oldFiles: [],
            newDirs: [],
            newFiles: [],
            isFile: false,
            isDirectory: false,
            error: null,
        };
        const stats = statSync(oldPath);
        if (stats) {
            if (stats.isFile()) {
                results.isFile = true;
            }
            else if (stats.isDirectory()) {
                results.isDirectory = true;
            }
            renameNewRecursiveSync(oldPath, newPath, results);
            if (!results.error) {
                if (results.isDirectory) {
                    const rmdirResults = rmdirSync(oldPath, { recursive: true });
                    if (rmdirResults.error) {
                        results.error = rmdirResults.error;
                    }
                    else {
                        results.oldDirs.push(...rmdirResults.removedDirs);
                        results.oldFiles.push(...rmdirResults.removedFiles);
                    }
                }
                else if (results.isFile) {
                    const unlinkResults = unlinkSync(oldPath);
                    if (unlinkResults.error) {
                        results.error = unlinkResults.error;
                    }
                    else {
                        results.oldFiles.push(oldPath);
                    }
                }
            }
        }
        else {
            results.error = `${oldPath} does not exist`;
        }
        return results;
    };
    const renameNewRecursiveSync = (oldPath, newPath, results) => {
        const itemStat = statSync(oldPath);
        if (itemStat && !results.error) {
            if (itemStat.isFile()) {
                const newFileParentDir = path$1.dirname(newPath);
                const mkdirResults = mkdirSync(newFileParentDir, { recursive: true });
                const fileContent = items.get(oldPath).data;
                const writeResults = writeFileSync(newPath, fileContent);
                results.newDirs.push(...mkdirResults.newDirs);
                results.renamed.push({
                    oldPath,
                    newPath,
                    isDirectory: false,
                    isFile: true,
                });
                if (writeResults.error) {
                    results.error = writeResults.error;
                }
                else {
                    results.newFiles.push(newPath);
                }
            }
            else if (itemStat.isDirectory()) {
                const oldDirItemChildPaths = readdirSync(oldPath);
                const mkdirResults = mkdirSync(newPath, { recursive: true });
                results.newDirs.push(...mkdirResults.newDirs);
                results.renamed.push({
                    oldPath,
                    newPath,
                    isDirectory: true,
                    isFile: false,
                });
                for (const oldDirItemChildPath of oldDirItemChildPaths) {
                    const newDirItemChildPath = oldDirItemChildPath.replace(oldPath, newPath);
                    renameNewRecursiveSync(oldDirItemChildPath, newDirItemChildPath, results);
                }
            }
        }
    };
    const resolvePath = (p) => normalize(p);
    const rmdirSync = (p, opts = {}) => {
        const results = {
            basename: path$1.basename(p),
            dirname: path$1.dirname(p),
            path: p,
            removedDirs: [],
            removedFiles: [],
            error: null,
        };
        rmdirSyncRecursive(p, opts, results);
        return results;
    };
    const rmdirSyncRecursive = (p, opts, results) => {
        if (!results.error) {
            p = normalize(p);
            const dirItemPaths = readdirSync(p);
            if (opts && opts.recursive) {
                for (const dirItemPath of dirItemPaths) {
                    const item = items.get(dirItemPath);
                    if (item) {
                        if (item.isDirectory) {
                            rmdirSyncRecursive(dirItemPath, opts, results);
                        }
                        else if (item.isFile) {
                            const unlinkResults = unlinkSync(dirItemPath);
                            if (unlinkResults.error) {
                                results.error = unlinkResults.error;
                            }
                            else {
                                results.removedFiles.push(dirItemPath);
                            }
                        }
                    }
                }
            }
            else {
                if (dirItemPaths.length > 0) {
                    results.error = `cannot delete directory that contains files/subdirectories`;
                    return;
                }
            }
            items.delete(p);
            emitDirectoryWatch(p, new Set());
            results.removedDirs.push(p);
        }
    };
    const rmdir = async (p, opts = {}) => rmdirSync(p, opts);
    const statSync = (p) => {
        p = normalize(p);
        const item = items.get(p);
        if (item && (item.isDirectory || item.isFile)) {
            const s = {
                isDirectory: () => item.isDirectory,
                isFile: () => item.isFile,
                isSymbolicLink: () => false,
                size: item.isFile ? item.data.length : 0,
            };
            return s;
        }
        return undefined;
    };
    const stat = async (p) => statSync(p);
    const unlinkSync = (p) => {
        p = normalize(p);
        const results = {
            basename: path$1.basename(p),
            dirname: path$1.dirname(p),
            path: p,
            error: null,
        };
        const item = items.get(p);
        if (item) {
            if (item.watcherCallbacks) {
                for (const watcherCallback of item.watcherCallbacks) {
                    watcherCallback(p, 'fileDelete');
                }
            }
            items.delete(p);
            emitDirectoryWatch(p, new Set());
        }
        return results;
    };
    const unlink = async (p) => unlinkSync(p);
    const watchDirectory = (p, dirWatcherCallback) => {
        p = normalize(p);
        const item = items.get(p);
        const close = () => {
            const closeItem = items.get(p);
            if (closeItem && closeItem.watcherCallbacks) {
                const index = closeItem.watcherCallbacks.indexOf(dirWatcherCallback);
                if (index > -1) {
                    closeItem.watcherCallbacks.splice(index, 1);
                }
            }
        };
        addDestory(close);
        if (item) {
            item.isDirectory = true;
            item.isFile = false;
            item.watcherCallbacks = item.watcherCallbacks || [];
            item.watcherCallbacks.push(dirWatcherCallback);
        }
        else {
            items.set(p, {
                basename: path$1.basename(p),
                dirname: path$1.dirname(p),
                isDirectory: true,
                isFile: false,
                watcherCallbacks: [dirWatcherCallback],
                data: undefined,
            });
        }
        return {
            close() {
                removeDestory(close);
                close();
            },
        };
    };
    const watchFile = (p, fileWatcherCallback) => {
        p = normalize(p);
        const item = items.get(p);
        const close = () => {
            const closeItem = items.get(p);
            if (closeItem && closeItem.watcherCallbacks) {
                const index = closeItem.watcherCallbacks.indexOf(fileWatcherCallback);
                if (index > -1) {
                    closeItem.watcherCallbacks.splice(index, 1);
                }
            }
        };
        addDestory(close);
        if (item) {
            item.isDirectory = false;
            item.isFile = true;
            item.watcherCallbacks = item.watcherCallbacks || [];
            item.watcherCallbacks.push(fileWatcherCallback);
        }
        else {
            items.set(p, {
                basename: path$1.basename(p),
                dirname: path$1.dirname(p),
                isDirectory: true,
                isFile: false,
                watcherCallbacks: [fileWatcherCallback],
                data: undefined,
            });
        }
        return {
            close() {
                removeDestory(close);
                close();
            },
        };
    };
    const emitDirectoryWatch = (p, emitted) => {
        const parentDir = normalize(path$1.dirname(p));
        const dirItem = items.get(parentDir);
        if (dirItem && dirItem.isDirectory && dirItem.watcherCallbacks) {
            for (const watcherCallback of dirItem.watcherCallbacks) {
                watcherCallback(p, null);
            }
        }
        if (!emitted.has(parentDir)) {
            emitted.add(parentDir);
            emitDirectoryWatch(parentDir, emitted);
        }
    };
    const writeFileSync = (p, data) => {
        p = normalize(p);
        const results = {
            path: p,
            error: null,
        };
        const item = items.get(p);
        if (item) {
            const hasChanged = item.data !== data;
            item.data = data;
            if (hasChanged && item.watcherCallbacks) {
                for (const watcherCallback of item.watcherCallbacks) {
                    watcherCallback(p, 'fileUpdate');
                }
            }
        }
        else {
            items.set(p, {
                basename: path$1.basename(p),
                dirname: path$1.dirname(p),
                isDirectory: false,
                isFile: true,
                watcherCallbacks: null,
                data,
            });
            emitDirectoryWatch(p, new Set());
        }
        return results;
    };
    const writeFile = async (p, data) => writeFileSync(p, data);
    const generateContentHash = async (content) => {
        const arrayBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(content));
        const hashArray = Array.from(new Uint8Array(arrayBuffer)); // convert buffer to byte array
        let hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string
        if (typeof length === 'number') {
            hashHex = hashHex.substr(0, length);
        }
        return hashHex;
    };
    const copy = async (copyTasks, srcDir) => {
        const results = {
            diagnostics: [],
            dirPaths: [],
            filePaths: [],
        };
        console.log('todo, copy task', copyTasks.length, srcDir);
        return results;
    };
    const fileWatchTimeout = 32;
    mkdirSync('/');
    const sys = {
        events,
        access,
        accessSync,
        addDestory,
        copyFile,
        destroy,
        encodeToBase64,
        watchTimeout: fileWatchTimeout,
        getCurrentDirectory,
        getCompilerExecutingPath,
        isSymbolicLink,
        mkdir,
        mkdirSync,
        normalizePath: normalize,
        readdir,
        readdirSync,
        readFile,
        readFileSync,
        realpath,
        realpathSync,
        removeDestory,
        rename,
        resolvePath,
        rmdir,
        rmdirSync,
        stat,
        statSync,
        unlink,
        unlinkSync,
        watchDirectory,
        watchFile,
        writeFile,
        writeFileSync,
        generateContentHash,
        createWorkerController: HAS_WEB_WORKER ? createWebWorkerMainController : null,
        details: getDetails(),
        copy,
    };
    sys.resolveModuleId = opts => resolveModuleIdAsync(sys, null, opts);
    return sys;
};
const getDetails = () => {
    const details = {
        cpuModel: '',
        cpus: -1,
        freemem() {
            return 0;
        },
        platform: '',
        release: '',
        runtime: 'node',
        runtimeVersion: '',
        tmpDir: '/.tmp',
        totalmem: -1,
    };
    return details;
};

const createTestingSystem = () => {
    let diskReads = 0;
    let diskWrites = 0;
    const sys = createSystem();
    sys.generateContentHash = (content, length) => {
        let hash = crypto$2.createHash('sha1')
            .update(content)
            .digest('hex')
            .toLowerCase();
        if (typeof length === 'number') {
            hash = hash.substr(0, length);
        }
        return Promise.resolve(hash);
    };
    const wrapRead = (fn) => {
        const orgFn = fn;
        return (...args) => {
            diskReads++;
            return orgFn.apply(orgFn, args);
        };
    };
    const wrapWrite = (fn) => {
        const orgFn = fn;
        return (...args) => {
            diskWrites++;
            return orgFn.apply(orgFn, args);
        };
    };
    sys.access = wrapRead(sys.access);
    sys.accessSync = wrapRead(sys.accessSync);
    sys.readFile = wrapRead(sys.readFile);
    sys.readFileSync = wrapRead(sys.readFileSync);
    sys.readdir = wrapRead(sys.readdir);
    sys.readdirSync = wrapRead(sys.readdirSync);
    sys.stat = wrapRead(sys.stat);
    sys.statSync = wrapRead(sys.statSync);
    sys.copyFile = wrapWrite(sys.copyFile);
    sys.mkdir = wrapWrite(sys.mkdir);
    sys.mkdirSync = wrapWrite(sys.mkdirSync);
    sys.unlink = wrapWrite(sys.unlink);
    sys.unlinkSync = wrapWrite(sys.unlinkSync);
    sys.writeFile = wrapWrite(sys.writeFile);
    sys.writeFileSync = wrapWrite(sys.writeFileSync);
    return Object.defineProperties(sys, {
        diskReads: {
            get() {
                return diskReads;
            },
            set(val) {
                diskReads = val;
            },
        },
        diskWrites: {
            get() {
                return diskWrites;
            },
            set(val) {
                diskWrites = val;
            },
        },
    });
};

class TestingLogger {
    constructor() {
        this.colors = false;
        this.enable = false;
        this.buildLogFilePath = null;
    }
    info(...msg) {
        if (this.enable) {
            console.log.apply(console, msg);
        }
    }
    warn(...msg) {
        if (this.enable) {
            console.warn.apply(console, msg);
        }
    }
    error(...msg) {
        if (this.enable) {
            console.error.apply(console, msg);
        }
    }
    debug(...msg) {
        if (this.enable) {
            console.log.apply(console, msg);
        }
    }
    color(_msg, _color) {
        /* */
    }
    red(msg) {
        return msg;
    }
    green(msg) {
        return msg;
    }
    yellow(msg) {
        return msg;
    }
    blue(msg) {
        return msg;
    }
    magenta(msg) {
        return msg;
    }
    cyan(msg) {
        return msg;
    }
    gray(msg) {
        return msg;
    }
    bold(msg) {
        return msg;
    }
    dim(msg) {
        return msg;
    }
    bgRed(msg) {
        return msg;
    }
    createTimeSpan(_startMsg, _debug = false) {
        return {
            duration() {
                return 0;
            },
            finish() {
                return 0;
            },
        };
    }
    printDiagnostics(_diagnostics) {
        /* */
    }
    writeLogs(_) {
        /**/
    }
}

function mockConfig(sys) {
    if (!sys) {
        sys = createTestingSystem();
    }
    const rootDir = path$1__default.resolve('/');
    const config = {
        _isTesting: true,
        namespace: 'Testing',
        rootDir: rootDir,
        cwd: rootDir,
        globalScript: null,
        devMode: true,
        enableCache: false,
        buildAppCore: false,
        buildDist: true,
        flags: {},
        bundles: null,
        outputTargets: null,
        buildEs5: false,
        hashFileNames: false,
        logger: new TestingLogger(),
        maxConcurrentWorkers: 0,
        minifyCss: false,
        minifyJs: false,
        sys,
        testing: null,
        validateTypes: false,
        extras: {},
        nodeResolve: {
            customResolveOptions: {},
        },
    };
    return config;
}
function mockCompilerCtx(config) {
    const compilerCtx = {
        version: 1,
        activeBuildId: 0,
        activeDirsAdded: [],
        activeDirsDeleted: [],
        activeFilesAdded: [],
        activeFilesDeleted: [],
        activeFilesUpdated: [],
        fs: null,
        cachedGlobalStyle: null,
        collections: [],
        compilerOptions: null,
        cache: null,
        cachedStyleMeta: new Map(),
        events: null,
        fsWatcher: null,
        hasSuccessfulBuild: false,
        isActivelyBuilding: false,
        lastComponentStyleInput: new Map(),
        lastBuildResults: null,
        lastBuildStyles: null,
        moduleMap: new Map(),
        nodeMap: new WeakMap(),
        resolvedCollections: new Set(),
        rollupCacheHydrate: null,
        rollupCacheLazy: null,
        rollupCacheNative: null,
        rollupCache: new Map(),
        rootTsFiles: [],
        styleModeNames: new Set(),
        tsService: null,
        changedModules: new Set(),
        changedFiles: new Set(),
        reset: () => {
            /**/
        },
        worker: stencil_js.createWorkerContext(),
    };
    Object.defineProperty(compilerCtx, 'fs', {
        get() {
            if (this._fs == null) {
                this._fs = createInMemoryFs(config.sys);
            }
            return this._fs;
        },
    });
    Object.defineProperty(compilerCtx, 'cache', {
        get() {
            if (this._cache == null) {
                this._cache = mockCache(config, compilerCtx);
            }
            return this._cache;
        },
    });
    return compilerCtx;
}
function mockBuildCtx(config, compilerCtx) {
    if (!config) {
        config = mockConfig();
    }
    if (!compilerCtx) {
        compilerCtx = mockCompilerCtx(config);
    }
    const buildCtx = new BuildContext(config, compilerCtx);
    return buildCtx;
}
function mockCache(config, compilerCtx) {
    if (!config) {
        config = mockConfig();
    }
    if (!compilerCtx) {
        compilerCtx = mockCompilerCtx(config);
    }
    config.enableCache = true;
    const cache = new Cache(config, compilerCtx.fs);
    cache.initCacheDir();
    return cache;
}
function mockLogger() {
    return new TestingLogger();
}
function mockStencilSystem() {
    return createTestingSystem();
}
function mockDocument(html = null) {
    const win = new index_js$1.MockWindow(html);
    return win.document;
}
function mockWindow(html = null) {
    const win = new index_js$1.MockWindow(html);
    return win;
}

const getBuildFeatures = (cmps) => {
    const slot = cmps.some(c => c.htmlTagNames.includes('slot'));
    const shadowDom = cmps.some(c => c.encapsulation === 'shadow');
    const slotRelocation = cmps.some(c => c.encapsulation !== 'shadow' && c.htmlTagNames.includes('slot'));
    const f = {
        allRenderFn: cmps.every(c => c.hasRenderFn),
        cmpDidLoad: cmps.some(c => c.hasComponentDidLoadFn),
        cmpShouldUpdate: cmps.some(c => c.hasComponentShouldUpdateFn),
        cmpDidUnload: cmps.some(c => c.hasComponentDidUnloadFn),
        cmpDidUpdate: cmps.some(c => c.hasComponentDidUpdateFn),
        cmpDidRender: cmps.some(c => c.hasComponentDidRenderFn),
        cmpWillLoad: cmps.some(c => c.hasComponentWillLoadFn),
        cmpWillUpdate: cmps.some(c => c.hasComponentWillUpdateFn),
        cmpWillRender: cmps.some(c => c.hasComponentWillRenderFn),
        connectedCallback: cmps.some(c => c.hasConnectedCallbackFn),
        disconnectedCallback: cmps.some(c => c.hasDisconnectedCallbackFn),
        element: cmps.some(c => c.hasElement),
        event: cmps.some(c => c.hasEvent),
        hasRenderFn: cmps.some(c => c.hasRenderFn),
        lifecycle: cmps.some(c => c.hasLifecycle),
        asyncLoading: false,
        hostListener: cmps.some(c => c.hasListener),
        hostListenerTargetWindow: cmps.some(c => c.hasListenerTargetWindow),
        hostListenerTargetDocument: cmps.some(c => c.hasListenerTargetDocument),
        hostListenerTargetBody: cmps.some(c => c.hasListenerTargetBody),
        hostListenerTargetParent: cmps.some(c => c.hasListenerTargetParent),
        hostListenerTarget: cmps.some(c => c.hasListenerTarget),
        member: cmps.some(c => c.hasMember),
        method: cmps.some(c => c.hasMethod),
        mode: cmps.some(c => c.hasMode),
        observeAttribute: cmps.some(c => c.hasAttribute),
        prop: cmps.some(c => c.hasProp),
        propBoolean: cmps.some(c => c.hasPropBoolean),
        propNumber: cmps.some(c => c.hasPropNumber),
        propString: cmps.some(c => c.hasPropString),
        propMutable: cmps.some(c => c.hasPropMutable),
        reflect: cmps.some(c => c.hasReflect),
        scoped: cmps.some(c => c.encapsulation === 'scoped'),
        shadowDom,
        shadowDelegatesFocus: shadowDom && cmps.some(c => c.shadowDelegatesFocus),
        slot,
        slotRelocation,
        state: cmps.some(c => c.hasState),
        style: cmps.some(c => c.hasStyle),
        svg: cmps.some(c => c.htmlTagNames.includes('svg')),
        updatable: cmps.some(c => c.isUpdateable),
        vdomAttribute: cmps.some(c => c.hasVdomAttribute),
        vdomXlink: cmps.some(c => c.hasVdomXlink),
        vdomClass: cmps.some(c => c.hasVdomClass),
        vdomFunctional: cmps.some(c => c.hasVdomFunctional),
        vdomKey: cmps.some(c => c.hasVdomKey),
        vdomListener: cmps.some(c => c.hasVdomListener),
        vdomPropOrAttr: cmps.some(c => c.hasVdomPropOrAttr),
        vdomRef: cmps.some(c => c.hasVdomRef),
        vdomRender: cmps.some(c => c.hasVdomRender),
        vdomStyle: cmps.some(c => c.hasVdomStyle),
        vdomText: cmps.some(c => c.hasVdomText),
        watchCallback: cmps.some(c => c.hasWatchCallback),
        taskQueue: true,
    };
    f.asyncLoading = f.cmpWillUpdate || f.cmpWillLoad || f.cmpWillRender;
    f.vdomAttribute = f.vdomAttribute || f.reflect;
    f.vdomPropOrAttr = f.vdomPropOrAttr || f.reflect;
    return f;
};

async function newSpecPage(opts) {
    if (opts == null) {
        throw new Error(`NewSpecPageOptions required`);
    }
    // reset the platform for this new test
    testing.resetPlatform();
    resetBuildConditionals(appData.BUILD);
    testing.registerContext(opts.context);
    if (Array.isArray(opts.components)) {
        testing.registerComponents(opts.components);
    }
    if (opts.hydrateClientSide) {
        opts.includeAnnotations = true;
    }
    if (opts.hydrateServerSide) {
        opts.includeAnnotations = true;
        testing.setSupportsShadowDom(false);
    }
    else {
        opts.includeAnnotations = !!opts.includeAnnotations;
        if (opts.supportsShadowDom === false) {
            testing.setSupportsShadowDom(false);
        }
        else {
            testing.setSupportsShadowDom(true);
        }
    }
    appData.BUILD.cssAnnotations = opts.includeAnnotations;
    const cmpTags = new Set();
    testing.win['__stencil_spec_options'] = opts;
    const doc = testing.win.document;
    const page = {
        win: testing.win,
        doc: doc,
        body: doc.body,
        build: appData.BUILD,
        styles: testing.styles,
        setContent: html => {
            doc.body.innerHTML = html;
            return testing.flushAll();
        },
        waitForChanges: testing.flushAll,
        flushLoadModule: testing.flushLoadModule,
        flushQueue: testing.flushQueue,
    };
    const lazyBundles = opts.components.map((Cstr) => {
        if (Cstr.COMPILER_META == null) {
            throw new Error(`Invalid component class: Missing static "COMPILER_META" property.`);
        }
        cmpTags.add(Cstr.COMPILER_META.tagName);
        Cstr.isProxied = false;
        proxyComponentLifeCycles(Cstr);
        const textBundleId = `${Cstr.COMPILER_META.tagName}.${Math.round(Math.random() * 899999) + 100000}`;
        const stylesMeta = Cstr.COMPILER_META.styles;
        let bundleId = textBundleId;
        if (Array.isArray(stylesMeta)) {
            stylesMeta.forEach(style => {
                testing.styles.set(style.styleId, style.styleStr);
            });
            if (stylesMeta.length > 1) {
                bundleId = {};
                stylesMeta.forEach(style => {
                    bundleId[style.styleId] = textBundleId;
                });
            }
        }
        testing.registerModule(bundleId, Cstr);
        const lazyBundleRuntimeMeta = formatLazyBundleRuntimeMeta(bundleId, [Cstr.COMPILER_META]);
        return lazyBundleRuntimeMeta;
    });
    const cmpCompilerMeta = opts.components.map(Cstr => Cstr.COMPILER_META);
    const cmpBuild = getBuildFeatures(cmpCompilerMeta);
    if (opts.strictBuild) {
        Object.assign(appData.BUILD, cmpBuild);
    }
    else {
        Object.keys(cmpBuild).forEach(key => {
            if (cmpBuild[key] === true) {
                appData.BUILD[key] = true;
            }
        });
    }
    appData.BUILD.asyncLoading = true;
    if (opts.hydrateClientSide) {
        appData.BUILD.hydrateClientSide = true;
        appData.BUILD.hydrateServerSide = false;
    }
    else if (opts.hydrateServerSide) {
        appData.BUILD.hydrateServerSide = true;
        appData.BUILD.hydrateClientSide = false;
    }
    appData.BUILD.cloneNodeFix = false;
    appData.BUILD.shadowDomShim = false;
    appData.BUILD.safari10 = false;
    page.flush = () => {
        console.warn(`DEPRECATED: page.flush(), please use page.waitForChanges() instead`);
        return page.waitForChanges();
    };
    if (typeof opts.url === 'string') {
        page.win.location.href = opts.url;
    }
    if (typeof opts.direction === 'string') {
        page.doc.documentElement.setAttribute('dir', opts.direction);
    }
    if (typeof opts.language === 'string') {
        page.doc.documentElement.setAttribute('lang', opts.language);
    }
    if (typeof opts.cookie === 'string') {
        try {
            page.doc.cookie = opts.cookie;
        }
        catch (e) { }
    }
    if (typeof opts.referrer === 'string') {
        try {
            page.doc.referrer = opts.referrer;
        }
        catch (e) { }
    }
    if (typeof opts.userAgent === 'string') {
        try {
            page.win.navigator.userAgent = opts.userAgent;
        }
        catch (e) { }
    }
    testing.bootstrapLazy(lazyBundles);
    if (typeof opts.template === 'function') {
        const cmpMeta = {
            $flags$: 0,
            $tagName$: 'body',
        };
        const ref = {
            $ancestorComponent$: undefined,
            $flags$: 0,
            $modeName$: undefined,
            $cmpMeta$: cmpMeta,
            $hostElement$: page.body,
        };
        testing.renderVdom(ref, opts.template());
    }
    else if (typeof opts.html === 'string') {
        page.body.innerHTML = opts.html;
    }
    if (opts.flushQueue !== false) {
        await page.waitForChanges();
    }
    let rootComponent = null;
    Object.defineProperty(page, 'root', {
        get() {
            if (rootComponent == null) {
                rootComponent = findRootComponent(cmpTags, page.body);
            }
            if (rootComponent != null) {
                return rootComponent;
            }
            const firstElementChild = page.body.firstElementChild;
            if (firstElementChild != null) {
                return firstElementChild;
            }
            return null;
        },
    });
    Object.defineProperty(page, 'rootInstance', {
        get() {
            const hostRef = testing.getHostRef(page.root);
            if (hostRef != null) {
                return hostRef.$lazyInstance$;
            }
            return null;
        },
    });
    if (opts.hydrateServerSide) {
        testing.insertVdomAnnotations(doc, []);
    }
    if (opts.autoApplyChanges) {
        testing.startAutoApplyChanges();
        page.waitForChanges = () => {
            console.error('waitForChanges() cannot be used manually if the "startAutoApplyChanges" option is enabled');
            return Promise.resolve();
        };
    }
    return page;
}
function proxyComponentLifeCycles(Cstr) {
    if (typeof Cstr.prototype.__componentWillLoad === 'function') {
        Cstr.prototype.componentWillLoad = Cstr.prototype.__componentWillLoad;
        Cstr.prototype.__componentWillLoad = null;
    }
    if (typeof Cstr.prototype.__componentWillUpdate === 'function') {
        Cstr.prototype.componentWillUpdate = Cstr.prototype.__componentWillUpdate;
        Cstr.prototype.__componentWillUpdate = null;
    }
    if (typeof Cstr.prototype.__componentWillRender === 'function') {
        Cstr.prototype.componentWillRender = Cstr.prototype.__componentWillRender;
        Cstr.prototype.__componentWillRender = null;
    }
    if (typeof Cstr.prototype.componentWillLoad === 'function') {
        Cstr.prototype.__componentWillLoad = Cstr.prototype.componentWillLoad;
        Cstr.prototype.componentWillLoad = function () {
            const result = this.__componentWillLoad();
            if (result != null && typeof result.then === 'function') {
                testing.writeTask(() => result);
            }
            else {
                testing.writeTask(() => Promise.resolve());
            }
            return result;
        };
    }
    if (typeof Cstr.prototype.componentWillUpdate === 'function') {
        Cstr.prototype.__componentWillUpdate = Cstr.prototype.componentWillUpdate;
        Cstr.prototype.componentWillUpdate = function () {
            const result = this.__componentWillUpdate();
            if (result != null && typeof result.then === 'function') {
                testing.writeTask(() => result);
            }
            else {
                testing.writeTask(() => Promise.resolve());
            }
            return result;
        };
    }
    if (typeof Cstr.prototype.componentWillRender === 'function') {
        Cstr.prototype.__componentWillRender = Cstr.prototype.componentWillRender;
        Cstr.prototype.componentWillRender = function () {
            const result = this.__componentWillRender();
            if (result != null && typeof result.then === 'function') {
                testing.writeTask(() => result);
            }
            else {
                testing.writeTask(() => Promise.resolve());
            }
            return result;
        };
    }
}
function findRootComponent(cmpTags, node) {
    if (node != null) {
        const children = node.children;
        const childrenLength = children.length;
        for (let i = 0; i < childrenLength; i++) {
            const elm = children[i];
            if (cmpTags.has(elm.nodeName.toLowerCase())) {
                return elm;
            }
        }
        for (let i = 0; i < childrenLength; i++) {
            const r = findRootComponent(cmpTags, children[i]);
            if (r != null) {
                return r;
            }
        }
    }
    return null;
}

async function initPageEvents(page) {
    page._e2eEvents = new Map();
    page._e2eEventIds = 0;
    page.spyOnEvent = pageSpyOnEvent.bind(page, page);
    await page.exposeFunction('stencilOnEvent', (id, ev) => {
        // NODE CONTEXT
        nodeContextEvents(page._e2eEvents, id, ev);
    });
    await page.evaluateOnNewDocument(browserContextEvents);
}
async function pageSpyOnEvent(page, eventName, selector) {
    const eventSpy = new EventSpy(eventName);
    const handler = selector !== 'document' ? () => window : () => document;
    const handle = await page.evaluateHandle(handler);
    await addE2EListener(page, handle, eventName, ev => {
        eventSpy.push(ev);
    });
    return eventSpy;
}
async function waitForEvent(page, eventName, elementHandle) {
    const timeoutMs = jasmine.DEFAULT_TIMEOUT_INTERVAL * 0.5;
    const ev = await page.evaluate((element, eventName, timeoutMs) => {
        return new Promise((resolve, reject) => {
            const tmr = setTimeout(() => {
                reject(new Error(`waitForEvent() timeout, eventName: ${eventName}`));
            }, timeoutMs);
            element.addEventListener(eventName, ev => {
                clearTimeout(tmr);
                resolve(window.stencilSerializeEvent(ev));
            }, { once: true });
        });
    }, elementHandle, eventName, timeoutMs);
    await page.waitForChanges();
    return ev;
}
class EventSpy {
    constructor(eventName) {
        this.eventName = eventName;
        this.events = [];
        this.cursor = 0;
        this.queuedHandler = [];
    }
    get length() {
        return this.events.length;
    }
    get firstEvent() {
        return this.events[0] || null;
    }
    get lastEvent() {
        return this.events[this.events.length - 1] || null;
    }
    next() {
        const cursor = this.cursor;
        this.cursor++;
        const next = this.events[cursor];
        if (next) {
            return Promise.resolve({
                done: false,
                value: next,
            });
        }
        else {
            let resolve;
            const promise = new Promise(r => (resolve = r));
            this.queuedHandler.push(resolve);
            return promise.then(() => ({
                done: false,
                value: this.events[cursor],
            }));
        }
    }
    push(ev) {
        this.events.push(ev);
        const next = this.queuedHandler.shift();
        if (next) {
            next();
        }
    }
}
async function addE2EListener(page, elmHandle, eventName, callback) {
    // NODE CONTEXT
    const id = page._e2eEventIds++;
    page._e2eEvents.set(id, {
        eventName,
        callback,
    });
    const executionContext = elmHandle.executionContext();
    // add element event listener
    await executionContext.evaluate((elm, id, eventName) => {
        elm.addEventListener(eventName, (ev) => {
            window.stencilOnEvent(id, window.stencilSerializeEvent(ev));
        });
    }, elmHandle, id, eventName);
}
function nodeContextEvents(waitForEvents, eventId, ev) {
    // NODE CONTEXT
    const waitForEventData = waitForEvents.get(eventId);
    if (waitForEventData) {
        waitForEventData.callback(ev);
    }
}
function browserContextEvents() {
    // BROWSER CONTEXT
    const waitFrame = () => {
        return new Promise(resolve => {
            requestAnimationFrame(resolve);
        });
    };
    const allReady = () => {
        const promises = [];
        const waitForDidLoad = (promises, elm) => {
            if (elm != null && elm.nodeType === 1) {
                for (let i = 0; i < elm.children.length; i++) {
                    const childElm = elm.children[i];
                    if (childElm.tagName.includes('-') && typeof childElm.componentOnReady === 'function') {
                        promises.push(childElm.componentOnReady());
                    }
                    waitForDidLoad(promises, childElm);
                }
            }
        };
        waitForDidLoad(promises, window.document.documentElement);
        return Promise.all(promises).catch(e => console.error(e));
    };
    const stencilReady = () => {
        return allReady()
            .then(() => waitFrame())
            .then(() => allReady())
            .then(() => {
            window.stencilAppLoaded = true;
        });
    };
    window.stencilSerializeEventTarget = (target) => {
        // BROWSER CONTEXT
        if (!target) {
            return null;
        }
        if (target === window) {
            return { serializedWindow: true };
        }
        if (target === document) {
            return { serializedDocument: true };
        }
        if (target.nodeType != null) {
            const serializedElement = {
                serializedElement: true,
                nodeName: target.nodeName,
                nodeValue: target.nodeValue,
                nodeType: target.nodeType,
                tagName: target.tagName,
                className: target.className,
                id: target.id,
            };
            return serializedElement;
        }
        return null;
    };
    window.stencilSerializeEvent = (orgEv) => {
        // BROWSER CONTEXT
        const serializedEvent = {
            bubbles: orgEv.bubbles,
            cancelBubble: orgEv.cancelBubble,
            cancelable: orgEv.cancelable,
            composed: orgEv.composed,
            currentTarget: window.stencilSerializeEventTarget(orgEv.currentTarget),
            defaultPrevented: orgEv.defaultPrevented,
            detail: orgEv.detail,
            eventPhase: orgEv.eventPhase,
            isTrusted: orgEv.isTrusted,
            returnValue: orgEv.returnValue,
            srcElement: window.stencilSerializeEventTarget(orgEv.srcElement),
            target: window.stencilSerializeEventTarget(orgEv.target),
            timeStamp: orgEv.timeStamp,
            type: orgEv.type,
            isSerializedEvent: true,
        };
        return serializedEvent;
    };
    if (window.document.readyState === 'complete') {
        stencilReady();
    }
    else {
        window.addEventListener('load', stencilReady);
    }
}

class E2EElement extends index_js$1.MockHTMLElement {
    constructor(_page, _elmHandle) {
        super(null, null);
        this._page = _page;
        this._elmHandle = _elmHandle;
        this._queuedActions = [];
        _page._e2eElements.push(this);
    }
    _queueAction(action) {
        this._queuedActions.push(action);
    }
    find(selector) {
        return find(this._page, this._elmHandle, selector);
    }
    findAll(selector) {
        return findAll(this._page, this._elmHandle, selector);
    }
    callMethod(methodName, ...methodArgs) {
        this._queueAction({
            methodName: methodName,
            methodArgs: methodArgs,
        });
        return this.e2eRunActions();
    }
    triggerEvent(eventName, eventInitDict) {
        this._queueAction({
            eventName: eventName,
            eventInitDict: eventInitDict,
        });
    }
    async spyOnEvent(eventName) {
        const eventSpy = new EventSpy(eventName);
        await addE2EListener(this._page, this._elmHandle, eventName, (ev) => {
            eventSpy.push(ev);
        });
        return eventSpy;
    }
    async click(options) {
        await this._elmHandle.click(options);
        await this._page.waitForChanges();
    }
    async focus() {
        await this._elmHandle.focus();
        await this._page.waitForChanges();
    }
    async hover() {
        await this._elmHandle.hover();
        await this._page.waitForChanges();
    }
    async isVisible() {
        this._validate();
        let isVisible = false;
        try {
            const executionContext = this._elmHandle.executionContext();
            isVisible = await executionContext.evaluate((elm) => {
                return new Promise(resolve => {
                    window.requestAnimationFrame(() => {
                        if (elm.isConnected) {
                            const style = window.getComputedStyle(elm);
                            const isVisible = !!style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
                            if (isVisible) {
                                window.requestAnimationFrame(() => {
                                    elm.clientWidth;
                                    resolve(true);
                                });
                            }
                            else {
                                resolve(false);
                            }
                        }
                        else {
                            resolve(false);
                        }
                    });
                });
            }, this._elmHandle);
        }
        catch (e) { }
        return isVisible;
    }
    waitForEvent(eventName) {
        return waitForEvent(this._page, eventName, this._elmHandle);
    }
    waitForVisible() {
        return new Promise((resolve, reject) => {
            const checkVisible = async () => {
                const isVisible = await this.isVisible();
                if (isVisible) {
                    clearInterval(resolveTmr);
                    clearTimeout(rejectTmr);
                    resolve();
                }
            };
            const resolveTmr = setInterval(checkVisible, 10);
            const timeout = jasmine.DEFAULT_TIMEOUT_INTERVAL * 0.5;
            const timeoutError = new Error(`waitForVisible timed out: ${timeout}ms`);
            const rejectTmr = setTimeout(() => {
                clearTimeout(resolveTmr);
                reject(timeoutError);
            }, timeout);
        });
    }
    waitForNotVisible() {
        return new Promise((resolve, reject) => {
            const checkVisible = async () => {
                const isVisible = await this.isVisible();
                if (!isVisible) {
                    clearInterval(resolveTmr);
                    clearTimeout(rejectTmr);
                    resolve();
                }
            };
            const resolveTmr = setInterval(checkVisible, 10);
            const timeout = jasmine.DEFAULT_TIMEOUT_INTERVAL * 0.5;
            const timeoutError = new Error(`waitForNotVisible timed out: ${timeout}ms`);
            const rejectTmr = setTimeout(() => {
                clearTimeout(resolveTmr);
                reject(timeoutError);
            }, timeout);
        });
    }
    isIntersectingViewport() {
        return this._elmHandle.isIntersectingViewport();
    }
    async press(key, options) {
        await this._elmHandle.press(key, options);
        await this._page.waitForChanges();
    }
    async tap() {
        await this._elmHandle.tap();
        await this._page.waitForChanges();
    }
    async type(text, options) {
        await this._elmHandle.type(text, options);
        await this._page.waitForChanges();
    }
    async getProperty(propertyName) {
        this._validate();
        const executionContext = this._elmHandle.executionContext();
        const propValue = await executionContext.evaluate((elm, propertyName) => {
            return elm[propertyName];
        }, this._elmHandle, propertyName);
        return propValue;
    }
    setProperty(propertyName, value) {
        this._queueAction({
            setPropertyName: propertyName,
            setPropertyValue: value,
        });
    }
    getAttribute(name) {
        this._validate();
        return super.getAttribute(name);
    }
    setAttribute(name, value) {
        this._queueAction({
            setAttributeName: name,
            setAttributeValue: value,
        });
    }
    removeAttribute(name) {
        this._queueAction({
            removeAttribute: name,
        });
    }
    toggleAttribute(name, force) {
        this._queueAction({
            toggleAttributeName: name,
            toggleAttributeForce: force,
        });
    }
    get classList() {
        const api = {
            add: (...classNames) => {
                classNames.forEach(className => {
                    this._queueAction({
                        classAdd: className,
                    });
                });
            },
            remove: (...classNames) => {
                classNames.forEach(className => {
                    this._queueAction({
                        classRemove: className,
                    });
                });
            },
            toggle: (className) => {
                this._queueAction({
                    classToggle: className,
                });
            },
            contains: (className) => {
                this._validate();
                return super.className.split(' ').includes(className);
            },
        };
        return api;
    }
    get className() {
        this._validate();
        return super.className;
    }
    set className(value) {
        this._queueAction({
            setPropertyName: 'className',
            setPropertyValue: value,
        });
    }
    get id() {
        this._validate();
        return super.id;
    }
    set id(value) {
        this._queueAction({
            setPropertyName: 'id',
            setPropertyValue: value,
        });
    }
    get innerHTML() {
        this._validate();
        return super.innerHTML;
    }
    set innerHTML(value) {
        this._queueAction({
            setPropertyName: 'innerHTML',
            setPropertyValue: value,
        });
    }
    get innerText() {
        this._validate();
        return super.innerText;
    }
    set innerText(value) {
        this._queueAction({
            setPropertyName: 'innerText',
            setPropertyValue: value,
        });
    }
    get nodeValue() {
        this._validate();
        return super.nodeValue;
    }
    set nodeValue(value) {
        if (typeof value === 'string') {
            this._queueAction({
                setPropertyName: 'nodeValue',
                setPropertyValue: value,
            });
        }
    }
    get outerHTML() {
        this._validate();
        return super.outerHTML;
    }
    set outerHTML(_) {
        throw new Error(`outerHTML is read-only`);
    }
    get shadowRoot() {
        this._validate();
        return super.shadowRoot;
    }
    set shadowRoot(value) {
        super.shadowRoot = value;
    }
    get tabIndex() {
        this._validate();
        return super.tabIndex;
    }
    set tabIndex(value) {
        this._queueAction({
            setPropertyName: 'tabIndex',
            setPropertyValue: value,
        });
    }
    get textContent() {
        this._validate();
        return super.textContent;
    }
    set textContent(value) {
        this._queueAction({
            setPropertyName: 'textContent',
            setPropertyValue: value,
        });
    }
    get title() {
        this._validate();
        return super.title;
    }
    set title(value) {
        this._queueAction({
            setPropertyName: 'title',
            setPropertyValue: value,
        });
    }
    async getComputedStyle(pseudoElt) {
        const style = await this._page.evaluate((elm, pseudoElt) => {
            const rtn = {};
            const computedStyle = window.getComputedStyle(elm, pseudoElt);
            const keys = Object.keys(computedStyle);
            keys.forEach(key => {
                if (isNaN(key)) {
                    const value = computedStyle[key];
                    if (value != null) {
                        rtn[key] = value;
                    }
                }
                else {
                    const dashProp = computedStyle[key];
                    if (dashProp.includes('-')) {
                        const value = computedStyle.getPropertyValue(dashProp);
                        if (value != null) {
                            rtn[dashProp] = value;
                        }
                    }
                }
            });
            return rtn;
        }, this._elmHandle, pseudoElt);
        style.getPropertyValue = (propName) => {
            return style[propName];
        };
        return style;
    }
    async e2eRunActions() {
        if (this._queuedActions.length === 0) {
            return;
        }
        const executionContext = this._elmHandle.executionContext();
        const rtn = await executionContext.evaluate((elm, queuedActions) => {
            // BROWSER CONTEXT
            // cannot use async/await in here cuz typescript transpiles it in the node context
            return elm.componentOnReady().then(() => {
                let rtn = null;
                queuedActions.forEach(queuedAction => {
                    if (queuedAction.methodName) {
                        rtn = elm[queuedAction.methodName].apply(elm, queuedAction.methodArgs);
                    }
                    else if (queuedAction.setPropertyName) {
                        elm[queuedAction.setPropertyName] = queuedAction.setPropertyValue;
                    }
                    else if (queuedAction.setAttributeName) {
                        elm.setAttribute(queuedAction.setAttributeName, queuedAction.setAttributeValue);
                    }
                    else if (queuedAction.removeAttribute) {
                        elm.removeAttribute(queuedAction.removeAttribute);
                    }
                    else if (queuedAction.toggleAttributeName) {
                        if (typeof queuedAction.toggleAttributeForce === 'boolean') {
                            elm.toggleAttribute(queuedAction.toggleAttributeName, queuedAction.toggleAttributeForce);
                        }
                        else {
                            elm.toggleAttribute(queuedAction.toggleAttributeName);
                        }
                    }
                    else if (queuedAction.classAdd) {
                        elm.classList.add(queuedAction.classAdd);
                    }
                    else if (queuedAction.classRemove) {
                        elm.classList.remove(queuedAction.classRemove);
                    }
                    else if (queuedAction.classToggle) {
                        elm.classList.toggle(queuedAction.classToggle);
                    }
                    else if (queuedAction.eventName) {
                        const eventInitDict = queuedAction.eventInitDict || {};
                        if (typeof eventInitDict.bubbles !== 'boolean') {
                            eventInitDict.bubbles = true;
                        }
                        if (typeof eventInitDict.cancelable !== 'boolean') {
                            eventInitDict.cancelable = true;
                        }
                        if (typeof eventInitDict.composed !== 'boolean') {
                            eventInitDict.composed = true;
                        }
                        const ev = new CustomEvent(queuedAction.eventName, eventInitDict);
                        elm.dispatchEvent(ev);
                    }
                });
                if (rtn && typeof rtn.then === 'function') {
                    return rtn.then((value) => {
                        return value;
                    });
                }
                return rtn;
            });
        }, this._elmHandle, this._queuedActions);
        this._queuedActions.length = 0;
        return rtn;
    }
    async e2eSync() {
        const executionContext = this._elmHandle.executionContext();
        const { outerHTML, shadowRootHTML } = await executionContext.evaluate((elm) => {
            return {
                outerHTML: elm.outerHTML,
                shadowRootHTML: elm.shadowRoot ? elm.shadowRoot.innerHTML : null,
            };
        }, this._elmHandle);
        if (typeof shadowRootHTML === 'string') {
            this.shadowRoot = index_js$1.parseHtmlToFragment(shadowRootHTML);
            this.shadowRoot.host = this;
        }
        else {
            this.shadowRoot = null;
        }
        const frag = index_js$1.parseHtmlToFragment(outerHTML);
        const rootElm = frag.firstElementChild;
        this.nodeName = rootElm.nodeName;
        this.attributes = index_js$1.cloneAttributes(rootElm.attributes);
        while (this.childNodes.length > 0) {
            this.removeChild(this.childNodes[0]);
        }
        while (rootElm.childNodes.length > 0) {
            this.appendChild(rootElm.childNodes[0]);
        }
    }
    _validate() {
        if (this._queuedActions.length > 0) {
            throw new Error(`await page.waitForChanges() must be called before reading element information`);
        }
    }
    async e2eDispose() {
        if (this._elmHandle) {
            await this._elmHandle.dispose();
            this._elmHandle = null;
        }
        const index = this._page._e2eElements.indexOf(this);
        if (index > -1) {
            this._page._e2eElements.splice(index, 1);
        }
        this._page = null;
    }
}
async function find(page, rootHandle, selector) {
    const { lightSelector, shadowSelector, text, contains } = getSelector(selector);
    let elmHandle;
    if (typeof lightSelector === 'string') {
        elmHandle = await findWithCssSelector(page, rootHandle, lightSelector, shadowSelector);
    }
    else {
        elmHandle = await findWithText(page, rootHandle, text, contains);
    }
    if (!elmHandle) {
        return null;
    }
    const elm = new E2EElement(page, elmHandle);
    await elm.e2eSync();
    return elm;
}
async function findWithCssSelector(page, rootHandle, lightSelector, shadowSelector) {
    let elmHandle = await rootHandle.$(lightSelector);
    if (!elmHandle) {
        return null;
    }
    if (shadowSelector) {
        const shadowHandle = await page.evaluateHandle((elm, shadowSelector) => {
            if (!elm.shadowRoot) {
                throw new Error(`shadow root does not exist for element: ${elm.tagName.toLowerCase()}`);
            }
            return elm.shadowRoot.querySelector(shadowSelector);
        }, elmHandle, shadowSelector);
        await elmHandle.dispose();
        if (!shadowHandle) {
            return null;
        }
        elmHandle = shadowHandle.asElement();
    }
    return elmHandle;
}
async function findWithText(page, rootHandle, text, contains) {
    const jsHandle = await page.evaluateHandle((rootElm, text, contains) => {
        let foundElm = null;
        function checkContent(elm) {
            if (!elm || foundElm) {
                return;
            }
            if (elm.nodeType === 3) {
                if (typeof text === 'string' && elm.textContent.trim() === text) {
                    foundElm = elm.parentElement;
                    return;
                }
                if (typeof contains === 'string' && elm.textContent.includes(contains)) {
                    foundElm = elm.parentElement;
                    return;
                }
            }
            else {
                if (elm.nodeName === 'SCRIPT' || elm.nodeName === 'STYLE') {
                    return;
                }
                checkContent(elm.shadowRoot);
                if (elm.childNodes) {
                    for (let i = 0; i < elm.childNodes.length; i++) {
                        checkContent(elm.childNodes[i]);
                    }
                }
            }
        }
        checkContent(rootElm);
        return foundElm;
    }, rootHandle, text, contains);
    if (jsHandle) {
        return jsHandle.asElement();
    }
    return null;
}
async function findAll(page, rootHandle, selector) {
    const foundElms = [];
    const { lightSelector, shadowSelector } = getSelector(selector);
    const lightElmHandles = await rootHandle.$$(lightSelector);
    if (lightElmHandles.length === 0) {
        return foundElms;
    }
    if (shadowSelector) {
        // light dom selected, then shadow dom selected inside of light dom elements
        for (let i = 0; i < lightElmHandles.length; i++) {
            const executionContext = lightElmHandles[i].executionContext();
            const shadowJsHandle = await executionContext.evaluateHandle((elm, shadowSelector) => {
                if (!elm.shadowRoot) {
                    throw new Error(`shadow root does not exist for element: ${elm.tagName.toLowerCase()}`);
                }
                return elm.shadowRoot.querySelectorAll(shadowSelector);
            }, lightElmHandles[i], shadowSelector);
            await lightElmHandles[i].dispose();
            const shadowJsProperties = await shadowJsHandle.getProperties();
            await shadowJsHandle.dispose();
            for (const shadowJsProperty of shadowJsProperties.values()) {
                const shadowElmHandle = shadowJsProperty.asElement();
                if (shadowElmHandle) {
                    const elm = new E2EElement(page, shadowElmHandle);
                    await elm.e2eSync();
                    foundElms.push(elm);
                }
            }
        }
    }
    else {
        // light dom only
        for (let i = 0; i < lightElmHandles.length; i++) {
            const elm = new E2EElement(page, lightElmHandles[i]);
            await elm.e2eSync();
            foundElms.push(elm);
        }
    }
    return foundElms;
}
function getSelector(selector) {
    const rtn = {
        lightSelector: null,
        shadowSelector: null,
        text: null,
        contains: null,
    };
    if (typeof selector === 'string') {
        const splt = selector.split('>>>');
        rtn.lightSelector = splt[0].trim();
        rtn.shadowSelector = splt.length > 1 ? splt[1].trim() : null;
    }
    else if (typeof selector.text === 'string') {
        rtn.text = selector.text.trim();
    }
    else if (typeof selector.contains === 'string') {
        rtn.contains = selector.contains.trim();
    }
    else {
        throw new Error(`invalid find selector: ${selector}`);
    }
    return rtn;
}

async function writeScreenshotImage(imagePath, screenshotBuf) {
    const imageExists = await fileExists(imagePath);
    if (!imageExists) {
        await writeFile(imagePath, screenshotBuf);
    }
}
async function writeScreenshotData(dataDir, screenshotData) {
    const filePath = getDataFilePath(dataDir, screenshotData.id);
    const content = JSON.stringify(screenshotData, null, 2);
    await writeFile(filePath, content);
}
function getDataFilePath(dataDir, screenshotId) {
    const fileName = `${screenshotId}.json`;
    return path$1__default.join(dataDir, fileName);
}
function fileExists(filePath) {
    return new Promise(resolve => {
        fs$1.access(filePath, (err) => resolve(!err));
    });
}
function writeFile(filePath, data) {
    return new Promise((resolve, reject) => {
        fs$1.writeFile(filePath, data, (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}

async function compareScreenshot(emulateConfig, screenshotBuildData, currentScreenshotBuf, desc, width, height, testPath, pixelmatchThreshold) {
    const currentImageHash = crypto$2.createHash('md5')
        .update(currentScreenshotBuf)
        .digest('hex');
    const currentImageName = `${currentImageHash}.png`;
    const currentImagePath = path$1.join(screenshotBuildData.imagesDir, currentImageName);
    await writeScreenshotImage(currentImagePath, currentScreenshotBuf);
    currentScreenshotBuf = null;
    if (testPath) {
        testPath = normalizePath(path$1.relative(screenshotBuildData.rootDir, testPath));
    }
    // create the data we'll be saving as json
    // the "id" is what we use as a key to compare to sets of data
    // the "image" is a hash of the image file name
    // and what we can use to quickly see if they're identical or not
    const screenshotId = getScreenshotId(emulateConfig, desc);
    const screenshot = {
        id: screenshotId,
        image: currentImageName,
        device: emulateConfig.device,
        userAgent: emulateConfig.userAgent,
        desc: desc,
        testPath: testPath,
        width: width,
        height: height,
        deviceScaleFactor: emulateConfig.viewport.deviceScaleFactor,
        hasTouch: emulateConfig.viewport.hasTouch,
        isLandscape: emulateConfig.viewport.isLandscape,
        isMobile: emulateConfig.viewport.isMobile,
        diff: {
            id: screenshotId,
            desc: desc,
            imageA: currentImageName,
            imageB: currentImageName,
            mismatchedPixels: 0,
            device: emulateConfig.device,
            userAgent: emulateConfig.userAgent,
            width: width,
            height: height,
            deviceScaleFactor: emulateConfig.viewport.deviceScaleFactor,
            hasTouch: emulateConfig.viewport.hasTouch,
            isLandscape: emulateConfig.viewport.isLandscape,
            isMobile: emulateConfig.viewport.isMobile,
            allowableMismatchedPixels: screenshotBuildData.allowableMismatchedPixels,
            allowableMismatchedRatio: screenshotBuildData.allowableMismatchedRatio,
            testPath: testPath,
        },
    };
    if (screenshotBuildData.updateMaster) {
        // this data is going to become the master data
        // so no need to compare with previous versions
        await writeScreenshotData(screenshotBuildData.currentBuildDir, screenshot);
        return screenshot.diff;
    }
    const masterScreenshotImage = screenshotBuildData.masterScreenshots[screenshot.id];
    if (!masterScreenshotImage) {
        // didn't find a master screenshot to compare it to
        await writeScreenshotData(screenshotBuildData.currentBuildDir, screenshot);
        return screenshot.diff;
    }
    // set that the master data image as the image we're going to compare the current image to
    // imageB is already set as the current image
    screenshot.diff.imageA = masterScreenshotImage;
    // compare only if the image hashes are different
    if (screenshot.diff.imageA !== screenshot.diff.imageB) {
        // we know the images are not identical since they have different hashes
        // create a cache key from the two hashes
        screenshot.diff.cacheKey = getCacheKey(screenshot.diff.imageA, screenshot.diff.imageB, pixelmatchThreshold);
        // let's see if we've already calculated the mismatched pixels already
        const cachedMismatchedPixels = screenshotBuildData.cache[screenshot.diff.cacheKey];
        if (typeof cachedMismatchedPixels === 'number' && !isNaN(cachedMismatchedPixels)) {
            // awesome, we've got cached data so we
            // can skip having to do the heavy pixelmatch comparison
            screenshot.diff.mismatchedPixels = cachedMismatchedPixels;
        }
        else {
            // images are not identical
            // and we don't have any cached data so let's
            // compare the two images pixel by pixel to
            // figure out a mismatch value
            // figure out the actual width and height of the screenshot
            const naturalWidth = Math.round(emulateConfig.viewport.width * emulateConfig.viewport.deviceScaleFactor);
            const naturalHeight = Math.round(emulateConfig.viewport.height * emulateConfig.viewport.deviceScaleFactor);
            const pixelMatchInput = {
                imageAPath: path$1.join(screenshotBuildData.imagesDir, screenshot.diff.imageA),
                imageBPath: path$1.join(screenshotBuildData.imagesDir, screenshot.diff.imageB),
                width: naturalWidth,
                height: naturalHeight,
                pixelmatchThreshold: pixelmatchThreshold,
            };
            screenshot.diff.mismatchedPixels = await getMismatchedPixels(screenshotBuildData.pixelmatchModulePath, pixelMatchInput);
        }
    }
    await writeScreenshotData(screenshotBuildData.currentBuildDir, screenshot);
    return screenshot.diff;
}
async function getMismatchedPixels(pixelmatchModulePath, pixelMatchInput) {
    return new Promise((resolve, reject) => {
        const timeout = jasmine.DEFAULT_TIMEOUT_INTERVAL * 0.5;
        const tmr = setTimeout(() => {
            reject(`getMismatchedPixels timeout: ${timeout}ms`);
        }, timeout);
        try {
            const filteredExecArgs = process.execArgv.filter(v => !/^--(debug|inspect)/.test(v));
            const options = {
                execArgv: filteredExecArgs,
                env: process.env,
                cwd: process.cwd(),
                stdio: ['pipe', 'pipe', 'pipe', 'ipc'],
            };
            const pixelMatchProcess = child_process$1.fork(pixelmatchModulePath, [], options);
            pixelMatchProcess.on('message', (data) => {
                pixelMatchProcess.kill();
                clearTimeout(tmr);
                resolve(data);
            });
            pixelMatchProcess.on('error', err => {
                clearTimeout(tmr);
                reject(err);
            });
            pixelMatchProcess.send(pixelMatchInput);
        }
        catch (e) {
            clearTimeout(tmr);
            reject(`getMismatchedPixels error: ${e}`);
        }
    });
}
function getCacheKey(imageA, imageB, pixelmatchThreshold) {
    const hash = crypto$2.createHash('md5');
    hash.update(`${imageA}:${imageB}:${pixelmatchThreshold}`);
    return hash.digest('hex').substr(0, 10);
}
function getScreenshotId(emulateConfig, uniqueDescription) {
    if (typeof uniqueDescription !== 'string' || uniqueDescription.trim().length === 0) {
        throw new Error(`invalid test description`);
    }
    const hash = crypto$2.createHash('md5');
    hash.update(uniqueDescription + ':');
    hash.update(emulateConfig.userAgent + ':');
    hash.update(emulateConfig.viewport.width + ':');
    hash.update(emulateConfig.viewport.height + ':');
    hash.update(emulateConfig.viewport.deviceScaleFactor + ':');
    hash.update(emulateConfig.viewport.hasTouch + ':');
    hash.update(emulateConfig.viewport.isMobile + ':');
    return hash
        .digest('hex')
        .substr(0, 8)
        .toLowerCase();
}

function initPageScreenshot(page) {
    const env = process.env;
    if (env.__STENCIL_SCREENSHOT__ === 'true') {
        page.compareScreenshot = (a, b) => {
            const jestEnv = global;
            let desc = '';
            let testPath = '';
            if (jestEnv.currentSpec) {
                if (typeof jestEnv.currentSpec.fullName === 'string') {
                    desc = jestEnv.currentSpec.fullName;
                }
                if (typeof jestEnv.currentSpec.testPath === 'string') {
                    testPath = jestEnv.currentSpec.testPath;
                }
            }
            let opts;
            if (typeof a === 'string') {
                if (desc.length > 0) {
                    desc += ', ' + a;
                }
                else {
                    desc = a;
                }
                if (typeof b === 'object') {
                    opts = b;
                }
            }
            else if (typeof a === 'object') {
                opts = a;
            }
            desc = desc.trim();
            opts = opts || {};
            if (!desc) {
                throw new Error(`Invalid screenshot description in "${testPath}"`);
            }
            if (jestEnv.screenshotDescriptions.has(desc)) {
                throw new Error(`Screenshot description "${desc}" found in "${testPath}" cannot be used for multiple screenshots and must be unique. To make screenshot descriptions unique within the same test, use the first argument to "compareScreenshot", such as "compareScreenshot('more to the description')".`);
            }
            jestEnv.screenshotDescriptions.add(desc);
            return pageCompareScreenshot(page, env, desc, testPath, opts);
        };
    }
    else {
        // screen shot not enabled, so just skip over all the logic
        page.compareScreenshot = async () => {
            const diff = {
                mismatchedPixels: 0,
                allowableMismatchedPixels: 1,
                allowableMismatchedRatio: 1,
                desc: '',
                width: 1,
                height: 1,
                deviceScaleFactor: 1,
            };
            return diff;
        };
    }
}
async function pageCompareScreenshot(page, env, desc, testPath, opts) {
    if (typeof env.__STENCIL_EMULATE__ !== 'string') {
        throw new Error(`compareScreenshot, missing screenshot emulate env var`);
    }
    if (typeof env.__STENCIL_SCREENSHOT_BUILD__ !== 'string') {
        throw new Error(`compareScreenshot, missing screen build env var`);
    }
    const emulateConfig = JSON.parse(env.__STENCIL_EMULATE__);
    const screenshotBuildData = JSON.parse(env.__STENCIL_SCREENSHOT_BUILD__);
    await wait(screenshotBuildData.timeoutBeforeScreenshot);
    await page.evaluate(() => {
        return new Promise(resolve => {
            window.requestAnimationFrame(() => {
                resolve();
            });
        });
    });
    const screenshotOpts = createPuppeteerScreenshopOptions(opts);
    const screenshotBuf = await page.screenshot(screenshotOpts);
    const pixelmatchThreshold = typeof opts.pixelmatchThreshold === 'number' ? opts.pixelmatchThreshold : screenshotBuildData.pixelmatchThreshold;
    let width = emulateConfig.viewport.width;
    let height = emulateConfig.viewport.height;
    if (opts && opts.clip) {
        if (typeof opts.clip.width === 'number') {
            width = opts.clip.width;
        }
        if (typeof opts.clip.height === 'number') {
            height = opts.clip.height;
        }
    }
    const results = await compareScreenshot(emulateConfig, screenshotBuildData, screenshotBuf, desc, width, height, testPath, pixelmatchThreshold);
    return results;
}
function createPuppeteerScreenshopOptions(opts) {
    const puppeteerOpts = {
        type: 'png',
        fullPage: opts.fullPage,
        omitBackground: opts.omitBackground,
        encoding: 'binary',
    };
    if (opts.clip) {
        puppeteerOpts.clip = {
            x: opts.clip.x,
            y: opts.clip.y,
            width: opts.clip.width,
            height: opts.clip.height,
        };
    }
    return puppeteerOpts;
}
function wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

const env = process.env;
async function newE2EPage(opts = {}) {
    if (!global.__NEW_TEST_PAGE__) {
        throw new Error(`newE2EPage() is only available from E2E tests, and ran with the --e2e cmd line flag.`);
    }
    const page = await global.__NEW_TEST_PAGE__();
    const diagnostics = [];
    try {
        page._e2eElements = [];
        page._e2eGoto = page.goto;
        page._e2eClose = page.close;
        await setPageEmulate(page);
        await page.setCacheEnabled(false);
        await initPageEvents(page);
        initPageScreenshot(page);
        let docPromise = null;
        page.close = async (options) => {
            try {
                if (Array.isArray(page._e2eElements)) {
                    const disposes = page._e2eElements.map(async (elmHande) => {
                        if (typeof elmHande.e2eDispose === 'function') {
                            await elmHande.e2eDispose();
                        }
                    });
                    await Promise.all(disposes);
                }
            }
            catch (e) { }
            const noop = () => {
                throw new Error('The page was already closed');
            };
            page._e2eElements = noop;
            page._e2eEvents = noop;
            page._e2eGoto = noop;
            page.find = noop;
            page.debugger = noop;
            page.findAll = noop;
            page.compareScreenshot = noop;
            page.setContent = noop;
            page.spyOnEvent = noop;
            page.waitForChanges = noop;
            page.waitForEvent = noop;
            try {
                if (!page.isClosed()) {
                    await page._e2eClose(options);
                }
            }
            catch (e) { }
        };
        const getDocHandle = async () => {
            if (!docPromise) {
                docPromise = page.evaluateHandle(() => document);
            }
            const documentJsHandle = await docPromise;
            return documentJsHandle.asElement();
        };
        page.find = async (selector) => {
            const docHandle = await getDocHandle();
            return find(page, docHandle, selector);
        };
        page.findAll = async (selector) => {
            const docHandle = await getDocHandle();
            return findAll(page, docHandle, selector);
        };
        page.waitForEvent = async (eventName) => {
            const docHandle = await getDocHandle();
            return waitForEvent(page, eventName, docHandle);
        };
        page.getDiagnostics = () => {
            return diagnostics;
        };
        page.waitForChanges = waitForChanges.bind(null, page);
        page.debugger = () => {
            if (env.__STENCIL_E2E_DEVTOOLS__ !== 'true') {
                throw new Error('Set the --devtools flag in order to use E2EPage.debugger()');
            }
            return page.evaluate(() => {
                return new Promise(resolve => {
                    // tslint:disable-next-line: no-debugger
                    debugger;
                    resolve();
                });
            });
        };
        const failOnConsoleError = opts.failOnConsoleError === true;
        const failOnNetworkError = opts.failOnNetworkError === true;
        page.on('console', ev => {
            if (ev.type() === 'error') {
                diagnostics.push({
                    type: 'error',
                    message: ev.text(),
                    location: ev.location().url,
                });
                if (failOnConsoleError) {
                    fail(new Error(serializeConsoleMessage(ev)));
                }
            }
            consoleMessage(ev);
        });
        page.on('pageerror', (err) => {
            diagnostics.push({
                type: 'pageerror',
                message: err.message,
                location: err.stack,
            });
            fail(err);
        });
        page.on('requestfailed', req => {
            diagnostics.push({
                type: 'requestfailed',
                message: req.failure().errorText,
                location: req.url(),
            });
            if (failOnNetworkError) {
                fail(new Error(req.failure().errorText));
            }
            else {
                console.error('requestfailed', req.url());
            }
        });
        if (typeof opts.html === 'string') {
            await e2eSetContent(page, opts.html, { waitUntil: opts.waitUntil });
        }
        else if (typeof opts.url === 'string') {
            await e2eGoTo(page, opts.url, { waitUntil: opts.waitUntil });
        }
        else {
            page.goto = e2eGoTo.bind(null, page);
            page.setContent = e2eSetContent.bind(null, page);
        }
    }
    catch (e) {
        if (page) {
            if (!page.isClosed()) {
                await page.close();
            }
        }
        throw e;
    }
    return page;
}
async function e2eGoTo(page, url, options = {}) {
    if (page.isClosed()) {
        throw new Error('e2eGoTo unavailable: page already closed');
    }
    if (typeof url !== 'string') {
        throw new Error('invalid gotoTest() url');
    }
    if (!url.startsWith('/')) {
        throw new Error('gotoTest() url must start with /');
    }
    const browserUrl = env.__STENCIL_BROWSER_URL__;
    if (typeof browserUrl !== 'string') {
        throw new Error('invalid gotoTest() browser url');
    }
    const fullUrl = browserUrl + url.substring(1);
    if (!options.waitUntil) {
        options.waitUntil = env.__STENCIL_BROWSER_WAIT_UNTIL;
    }
    const rsp = await page._e2eGoto(fullUrl, options);
    if (!rsp.ok()) {
        throw new Error(`Testing unable to load ${url}, HTTP status: ${rsp.status()}`);
    }
    await waitForStencil(page);
    return rsp;
}
async function e2eSetContent(page, html, options = {}) {
    if (page.isClosed()) {
        throw new Error('e2eSetContent unavailable: page already closed');
    }
    if (typeof html !== 'string') {
        throw new Error('invalid e2eSetContent() html');
    }
    const output = [];
    const appScriptUrl = env.__STENCIL_APP_SCRIPT_URL__;
    if (typeof appScriptUrl !== 'string') {
        throw new Error('invalid e2eSetContent() app script url');
    }
    output.push(`<!doctype html>`);
    output.push(`<html>`);
    output.push(`<head>`);
    const appStyleUrl = env.__STENCIL_APP_STYLE_URL__;
    if (typeof appStyleUrl === 'string') {
        output.push(`<link rel="stylesheet" href="${appStyleUrl}">`);
    }
    output.push(`<script type="module" src="${appScriptUrl}"></script>`);
    output.push(`</head>`);
    output.push(`<body>`);
    output.push(html);
    output.push(`</body>`);
    output.push(`</html>`);
    const pageUrl = env.__STENCIL_BROWSER_URL__;
    await page.setRequestInterception(true);
    const interceptedReqCallback = (interceptedRequest) => {
        if (pageUrl === interceptedRequest.url()) {
            interceptedRequest.respond({
                status: 200,
                contentType: 'text/html',
                body: output.join('\n'),
            });
        }
        else {
            interceptedRequest.continue();
        }
    };
    page.on('request', interceptedReqCallback);
    if (!options.waitUntil) {
        options.waitUntil = env.__STENCIL_BROWSER_WAIT_UNTIL;
    }
    const rsp = await page._e2eGoto(pageUrl, options);
    if (!rsp.ok()) {
        throw new Error(`Testing unable to load content`);
    }
    await waitForStencil(page);
    return rsp;
}
async function waitForStencil(page) {
    try {
        await page.waitForFunction('window.stencilAppLoaded', { timeout: 4750 });
    }
    catch (e) {
        throw new Error(`App did not load in allowed time. Please ensure the content loads a stencil application.`);
    }
}
async function setPageEmulate(page) {
    if (page.isClosed()) {
        return;
    }
    const emulateJsonContent = env.__STENCIL_EMULATE__;
    if (!emulateJsonContent) {
        return;
    }
    const screenshotEmulate = JSON.parse(emulateJsonContent);
    const emulateOptions = {
        viewport: screenshotEmulate.viewport,
        userAgent: screenshotEmulate.userAgent,
    };
    await page.emulate(emulateOptions);
}
async function waitForChanges(page) {
    try {
        if (page.isClosed()) {
            return;
        }
        await Promise.all(page._e2eElements.map(elm => elm.e2eRunActions()));
        if (page.isClosed()) {
            return;
        }
        await page.evaluate(() => {
            // BROWSER CONTEXT
            return new Promise(resolve => {
                requestAnimationFrame(() => {
                    const promises = [];
                    const waitComponentOnReady = (elm, promises) => {
                        if (elm != null) {
                            if ('shadowRoot' in elm && elm.shadowRoot instanceof ShadowRoot) {
                                waitComponentOnReady(elm.shadowRoot, promises);
                            }
                            const children = elm.children;
                            const len = children.length;
                            for (let i = 0; i < len; i++) {
                                const childElm = children[i];
                                if (childElm != null) {
                                    if (childElm.tagName.includes('-') && typeof childElm.componentOnReady === 'function') {
                                        promises.push(childElm.componentOnReady());
                                    }
                                    waitComponentOnReady(childElm, promises);
                                }
                            }
                        }
                    };
                    waitComponentOnReady(document.documentElement, promises);
                    Promise.all(promises)
                        .then(() => {
                        resolve();
                    })
                        .catch(() => {
                        resolve();
                    });
                });
            });
        });
        if (page.isClosed()) {
            return;
        }
        await page.waitFor(100);
        await Promise.all(page._e2eElements.map(elm => elm.e2eSync()));
    }
    catch (e) { }
}
function consoleMessage(c) {
    const msg = serializeConsoleMessage(c);
    const type = c.type();
    const normalizedType = type === 'warning' ? 'warn' : type;
    if (normalizedType === 'debug') {
        // Skip debug messages
        return;
    }
    if (typeof console[normalizedType] === 'function') {
        console[normalizedType](msg);
    }
    else {
        console.log(type, msg);
    }
}
function serializeConsoleMessage(c) {
    return `${c.text()} ${serializeLocation(c.location())}`;
}
function serializeLocation(loc) {
    let locStr = '';
    if (loc && loc.url) {
        locStr = `\nLocation: ${loc.url}`;
        if (loc.lineNumber) {
            locStr += `:${loc.lineNumber}`;
        }
        if (loc.columnNumber) {
            locStr += `:${loc.columnNumber}`;
        }
    }
    return locStr;
}

if (typeof URL === 'undefined') {
    // polyfill global URL for Node version < 10.0.0
    global.URL = url$1.URL;
}

Object.defineProperty(exports, 'MockHeaders', {
    enumerable: true,
    get: function () {
        return index_js$1.MockHeaders;
    }
});
Object.defineProperty(exports, 'MockRequest', {
    enumerable: true,
    get: function () {
        return index_js$1.MockRequest;
    }
});
Object.defineProperty(exports, 'MockResponse', {
    enumerable: true,
    get: function () {
        return index_js$1.MockResponse;
    }
});
exports.createJestPuppeteerEnvironment = createJestPuppeteerEnvironment;
exports.createTestRunner = createTestRunner;
exports.createTesting = createTesting;
exports.jestPreprocessor = jestPreprocessor;
exports.jestSetupTestFramework = jestSetupTestFramework;
exports.mockBuildCtx = mockBuildCtx;
exports.mockCompilerCtx = mockCompilerCtx;
exports.mockConfig = mockConfig;
exports.mockDocument = mockDocument;
exports.mockFetch = mockFetch;
exports.mockLogger = mockLogger;
exports.mockStencilSystem = mockStencilSystem;
exports.mockWindow = mockWindow;
exports.newE2EPage = newE2EPage;
exports.newSpecPage = newSpecPage;
exports.shuffleArray = shuffleArray;
exports.transpile = transpile;
