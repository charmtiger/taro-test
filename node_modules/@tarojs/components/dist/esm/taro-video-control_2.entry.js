import { r as registerInstance, h, H as Host, g as getElement } from './core-42efd82a.js';
import { f as formatTime } from './utils-22e850ae.js';

const VideoControl = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.visible = false;
        this.isDraggingProgressBall = false;
        this.percentage = 0;
        this.progressDimentions = {
            left: 0,
            width: 0
        };
        this.calcPercentage = (pageX) => {
            let pos = pageX - this.progressDimentions.left;
            pos = Math.max(pos, 0);
            pos = Math.min(pos, this.progressDimentions.width);
            return pos / this.progressDimentions.width;
        };
        this.onDragProgressBallStart = () => {
            this.isDraggingProgressBall = true;
            this.hideControlsTimer && clearTimeout(this.hideControlsTimer);
        };
        this.onClickProgress = (e) => {
            e.stopPropagation();
            const percentage = this.calcPercentage(e.pageX);
            this.seekFunc(percentage * this.duration);
            this.toggleVisibility(true);
        };
    }
    onDocumentTouchMove(e) {
        if (!this.isDraggingProgressBall)
            return;
        const touchX = e.touches[0].pageX;
        this.percentage = this.calcPercentage(touchX);
        this.setProgressBall(this.percentage);
        this.setCurrentTime(this.percentage * this.duration);
    }
    onDocumentTouchEnd() {
        if (!this.isDraggingProgressBall)
            return;
        this.isDraggingProgressBall = false;
        this.seekFunc(this.percentage * this.duration);
        this.toggleVisibility(true);
    }
    async setProgressBall(percentage) {
        if (this.progressBallRef) {
            this.progressBallRef.style.left = `${percentage * 100}%`;
        }
    }
    async toggleVisibility(nextVisible) {
        const visible = nextVisible === undefined ? !this.visible : nextVisible;
        if (visible) {
            this.hideControlsTimer && clearTimeout(this.hideControlsTimer);
            if (this.isPlaying) {
                this.hideControlsTimer = setTimeout(() => {
                    this.toggleVisibility(false);
                }, 2000);
            }
            this.controlsRef.style.visibility = 'visible';
        }
        else {
            this.controlsRef.style.visibility = 'hidden';
        }
        this.visible = !!visible;
    }
    async getIsDraggingProgressBall() {
        return this.isDraggingProgressBall;
    }
    async setCurrentTime(time) {
        this.currentTimeRef.innerHTML = formatTime(time);
    }
    render() {
        const { controls, currentTime, duration, isPlaying, pauseFunc, playFunc, showPlayBtn, showProgress } = this;
        const formattedDuration = formatTime(duration);
        let playBtn;
        if (!showPlayBtn) {
            playBtn = null;
        }
        else if (isPlaying) {
            playBtn = h("div", { class: 'taro-video-control-button taro-video-control-button-pause', onClick: pauseFunc });
        }
        else {
            playBtn = h("div", { class: 'taro-video-control-button taro-video-control-button-play', onClick: playFunc });
        }
        return (h(Host, { class: 'taro-video-bar taro-video-bar-full' }, controls && (h("div", { class: 'taro-video-controls' }, playBtn, showProgress && (h("div", { class: 'taro-video-current-time', ref: dom => (this.currentTimeRef = dom) }, formatTime(currentTime))), showProgress && (h("div", { class: 'taro-video-progress-container', onClick: this.onClickProgress }, h("div", { class: 'taro-video-progress', ref: ref => {
                if (!ref)
                    return;
                const rect = ref.getBoundingClientRect();
                this.progressDimentions.left = rect.left;
                this.progressDimentions.width = rect.width;
            } }, h("div", { class: 'taro-video-progress-buffered', style: { width: '100%' } }), h("div", { class: 'taro-video-ball', ref: dom => (this.progressBallRef = dom), onTouchStart: this.onDragProgressBallStart, style: {
                left: `${formattedDuration ? (this.currentTime / duration) * 100 : 0}%`
            } }, h("div", { class: 'taro-video-inner' }))))), showProgress && h("div", { class: 'taro-video-duration' }, formattedDuration))), h("slot", null)));
    }
    get controlsRef() { return getElement(this); }
};

const VideoDanmu = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.list = [];
        this.danmuElList = [];
        this.currentTime = 0;
        this.enable = false;
        this.danmuList = [];
    }
    ensureProperties(danmu) {
        const clonedDanmu = Object.assign({}, danmu);
        if (!('time' in danmu)) {
            clonedDanmu.time = this.currentTime;
        }
        clonedDanmu.key = Math.random();
        clonedDanmu.bottom = `${Math.random() * 90 + 5}%`;
        return clonedDanmu;
    }
    async sendDanmu(danmuList = []) {
        if (Array.isArray(danmuList)) {
            this.list = [
                ...this.list,
                ...danmuList.map(danmu => this.ensureProperties(danmu))
            ];
        }
        else {
            const danmu = danmuList;
            this.list = [
                ...this.list,
                Object.assign({}, this.ensureProperties(danmu))
            ];
        }
    }
    async tick(currentTime) {
        this.currentTime = currentTime;
        if (!this.enable)
            return;
        const danmuList = this.list;
        /**
         * @todo 这个判断对拖拽进度的处理不严谨
         */
        const newDanmuList = danmuList.filter(({ time }) => {
            return currentTime - time < 4 && currentTime > time;
        });
        let shouldUpdate = false;
        const oldDanmuList = this.danmuList;
        if (newDanmuList.length !== oldDanmuList.length) {
            shouldUpdate = true;
        }
        else {
            shouldUpdate = newDanmuList.some(({ key }) => {
                return oldDanmuList.every((danmu) => {
                    return key !== danmu.key;
                });
            });
        }
        if (shouldUpdate) {
            this.danmuList = newDanmuList;
        }
    }
    componentDidUpdate() {
        requestAnimationFrame(() => {
            setTimeout(() => {
                const danmuElList = this.danmuElList.splice(0);
                danmuElList.forEach(danmu => {
                    danmu.style.left = '0';
                    danmu.style.webkitTransform = 'translateX(-100%)';
                    danmu.style.transform = 'translateX(-100%)';
                });
            });
        });
    }
    render() {
        if (!this.enable)
            return '';
        return (h(Host, { class: 'taro-video-danmu' }, this.danmuList.map(({ text, color, bottom, key }) => (h("p", { class: 'taro-video-danmu-item', key: key, style: {
                color,
                bottom
            }, ref: ref => {
                if (ref) {
                    this.danmuElList.push(ref);
                }
            } }, text)))));
    }
};

export { VideoControl as taro_video_control, VideoDanmu as taro_video_danmu };
