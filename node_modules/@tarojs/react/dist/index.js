'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Reconciler = _interopDefault(require('react-reconciler'));
var scheduler = require('scheduler');
var runtime = require('@tarojs/runtime');

function isString(o) {
    return typeof o === 'string';
}
function isObject(o) {
    return o !== null && typeof o === 'object';
}
function isFunction(o) {
    return typeof o === 'function';
}
function isNumber(o) {
    return typeof o === 'number';
}
var EMPTY_ARR = [];
var noop = function () {
    var _ = [], len = arguments.length;
    while ( len-- ) _[ len ] = arguments[ len ];
 };
var reportIssue = '如有疑问，请提交 issue 至：https://github.com/nervjs/taro/issues';
/**
 * ensure takes a condition and throw a error if the condition fails,
 * like failure::ensure: https://docs.rs/failure/0.1.1/failure/macro.ensure.html
 * @param condition condition.
 * @param msg error message.
 */
function ensure(condition, msg) {
    if (condition) {
        return;
    }
    throw new Error(msg + '\n' + reportIssue);
}
var touchEvents = {
    bindTouchStart: '',
    bindTouchMove: '',
    bindTouchEnd: '',
    bindTouchCancel: '',
    bindLongTap: ''
};
var View = Object.assign({ 'hover-class': singleQuote('none'), 'hover-stop-propagation': 'false', 'hover-start-time': '50', 'hover-stay-time': '400', animation: '' }, touchEvents);
var CoverView = Object.assign({ 'scroll-top': 'false' }, touchEvents);
var MovableView = Object.assign({ direction: 'none', inertia: 'false', 'out-of-bounds': 'false', x: '', y: '', damping: '20', friction: '2', disabled: '', scale: 'false', 'scale-min': '0.5', 'scale-max': '10', 'scale-value': '1', animation: 'true', bindChange: '', bindScale: '', htouchmove: '', vtouchmove: '', width: singleQuote('10px'), height: singleQuote('10px') }, touchEvents);
var ScrollView = Object.assign({ 'scroll-x': 'false', 'scroll-y': 'false', 'upper-threshold': '50', 'lower-threshold': '50', 'scroll-top': '', 'scroll-left': '', 'scroll-into-view': '', 'scroll-with-animation': 'false', 'enable-back-to-top': 'false', 'enable-flex': 'false', 'scroll-anchoring': ' false', bindScrolltoUpper: '', bindScrolltoLower: '', bindScroll: '' }, touchEvents);
function singleQuote(s) {
    return ("'" + s + "'");
}

function isEventName(s) {
    return s[0] === 'o' && s[1] === 'n';
}
var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function updateProps(dom, oldProps, newProps) {
    var i;
    for (i in oldProps) {
        if (!(i in newProps)) {
            setProperty(dom, i, null, oldProps[i]);
        }
    }
    for (i in newProps) {
        if (oldProps[i] !== newProps[i]) {
            setProperty(dom, i, newProps[i], oldProps[i]);
        }
    }
}
var listeners = new WeakMap();
function eventProxy(e) {
    var el = runtime.document.getElementById(e.currentTarget.id);
    listeners.get(el)[e.type](e);
}
function setEvent(dom, name, value, oldValue) {
    var isCapture = name.endsWith('Capture');
    var eventName = name.toLowerCase().slice(2);
    if (isCapture) {
        eventName = eventName.slice(0, -7);
    }
    if (eventName === 'click') {
        eventName = 'tap';
    }
    if (isFunction(value)) {
        if (!oldValue) {
            dom.addEventListener(eventName, eventProxy, isCapture);
        }
        var events = listeners.get(dom);
        if (!events) {
            listeners.set(dom, events = {});
        }
        events[eventName] = value;
    }
    else {
        dom.removeEventListener(eventName, eventProxy);
        var events$1 = listeners.get(dom);
        if (events$1) {
            delete events$1[eventName];
        }
    }
}
function setStyle(style, key, value) {
    style[key] =
        isNumber(value) && IS_NON_DIMENSIONAL.test(key) === false
            ? value + 'px'
            : value == null
                ? ''
                : value;
}
function setProperty(dom, name, value, oldValue) {
    name = name === 'className' ? 'class' : name;
    if (name === 'key' ||
        name === 'children' ||
        name === 'ref') ;
    else if (name === 'style') {
        var style = dom.style;
        if (isString(value)) {
            style.cssText = value;
        }
        else {
            if (isString(oldValue)) {
                style.cssText = '';
                oldValue = null;
            }
            if (isObject(oldValue)) {
                for (var i in oldValue) {
                    if (!(value && i in value)) {
                        setStyle(style, i, '');
                    }
                }
            }
            if (isObject(value)) {
                for (var i$1 in value) {
                    if (!oldValue || value[i$1] !== oldValue[i$1]) {
                        setStyle(style, i$1, value[i$1]);
                    }
                }
            }
        }
    }
    else if (isEventName(name)) {
        setEvent(dom, name, value, oldValue);
    }
    else if (!isFunction(value) &&
        name !== 'dangerouslySetInnerHTML' // TODO: 实现 innerHTML
    ) {
        if (value == null) {
            dom.removeAttribute(name);
        }
        else {
            dom.setAttribute(name, value);
        }
    }
}

/* eslint-disable @typescript-eslint/indent */
var scheduleDeferredCallback = scheduler.unstable_scheduleCallback;
var cancelDeferredCallback = scheduler.unstable_cancelCallback;
var now = scheduler.unstable_now;
function returnFalse() {
    return false;
}
var hostConfig = {
    createInstance: function createInstance(type) {
        return runtime.document.createElement(type);
    },
    createTextInstance: function createTextInstance(text) {
        return runtime.document.createTextNode(text);
    },
    getPublicInstance: function getPublicInstance(inst) {
        return inst;
    },
    getRootHostContext: function getRootHostContext() {
        return {};
    },
    getChildHostContext: function getChildHostContext() {
        return {};
    },
    appendChild: function appendChild(parent, child) {
        parent.appendChild(child);
    },
    appendInitialChild: function appendInitialChild(parent, child) {
        parent.appendChild(child);
    },
    appendChildToContainer: function appendChildToContainer(parent, child) {
        parent.appendChild(child);
    },
    removeChild: function removeChild(parent, child) {
        parent.removeChild(child);
    },
    removeChildFromContainer: function removeChildFromContainer(parent, child) {
        parent.removeChild(child);
    },
    insertBefore: function insertBefore(parent, child, refChild) {
        parent.insertBefore(child, refChild);
    },
    insertInContainerBefore: function insertInContainerBefore(parent, child, refChild) {
        parent.insertBefore(child, refChild);
    },
    commitTextUpdate: function commitTextUpdate(textInst, _, newText) {
        textInst.nodeValue = newText;
    },
    finalizeInitialChildren: function finalizeInitialChildren(dom, _, props) {
        updateProps(dom, {}, props);
        return false;
    },
    prepareUpdate: function prepareUpdate() {
        return EMPTY_ARR;
    },
    commitUpdate: function commitUpdate(dom, _payload, _type, oldProps, newProps) {
        updateProps(dom, oldProps, newProps);
    },
    shouldSetTextContent: returnFalse,
    shouldDeprioritizeSubtree: returnFalse,
    prepareForCommit: noop,
    resetAfterCommit: noop,
    commitMount: noop,
    now: now,
    scheduleDeferredCallback: scheduleDeferredCallback,
    cancelDeferredCallback: cancelDeferredCallback,
    clearTimeout: clearTimeout,
    setTimeout: setTimeout,
    noTimeout: -1,
    supportsMutation: true,
    supportsPersistence: false,
    isPrimaryRenderer: true,
    supportsHydration: false
};
var TaroReconciler = Reconciler(hostConfig);

var ContainerMap = new WeakMap();
var Root = function Root(renderer, domContainer) {
    this.renderer = renderer;
    this.internalRoot = renderer.createContainer(domContainer, false, false);
};
Root.prototype.render = function render (children, cb) {
    this.renderer.updateContainer(children, this.internalRoot, null, cb);
    return this.renderer.getPublicRootInstance(this.internalRoot);
};
Root.prototype.unmount = function unmount (cb) {
    this.renderer.updateContainer(null, this.internalRoot, null, cb);
};
function render(element, domContainer, cb) {
    var oldRoot = ContainerMap.get(domContainer);
    if (oldRoot != null) {
        return oldRoot.render(element, cb);
    }
    var root = new Root(TaroReconciler, domContainer);
    ContainerMap.set(domContainer, root);
    return root.render(element, cb);
}

/* eslint-disable @typescript-eslint/no-unused-vars */
var unstable_batchedUpdates = TaroReconciler.batchedUpdates;
function unmountComponentAtNode(dom) {
    ensure(dom && [1, 8, 9, 11].includes(dom.nodeType), 'unmountComponentAtNode(...): Target container is not a DOM element.');
    var root = ContainerMap.get(dom);
    if (!root)
        { return false; }
    unstable_batchedUpdates(function () {
        root.unmount(function () {
            ContainerMap.delete(dom);
        });
    });
    return true;
}
function findDOMNode(comp) {
    if (comp == null) {
        return null;
    }
    var nodeType = comp.nodeType;
    if (nodeType === 1 || nodeType === 3) {
        return comp;
    }
    return TaroReconciler.findHostInstance(comp);
}
var portalType = typeof Symbol === 'function' && Symbol.for
    ? Symbol.for('react.portal')
    : 0xeaca;
function createPortal(children, containerInfo, key) {
    return {
        $$typeof: portalType,
        key: key == null ? null : String(key),
        children: children,
        containerInfo: containerInfo,
        implementation: null
    };
}
var index = {
    render: render,
    unstable_batchedUpdates: unstable_batchedUpdates,
    unmountComponentAtNode: unmountComponentAtNode,
    findDOMNode: findDOMNode,
    createPortal: createPortal
};

exports.createPortal = createPortal;
exports.default = index;
exports.findDOMNode = findDOMNode;
exports.render = render;
exports.unmountComponentAtNode = unmountComponentAtNode;
exports.unstable_batchedUpdates = unstable_batchedUpdates;
//# sourceMappingURL=index.js.map
