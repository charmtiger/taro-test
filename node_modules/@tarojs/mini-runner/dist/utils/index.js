"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs-extra");
const resolvePath = require("resolve");
const t = require("babel-types");
const runner_utils_1 = require("@tarojs/runner-utils");
function isQuickAppPkg(name) {
    return /^@(system|service)\.[a-zA-Z]{1,}/.test(name);
}
exports.isQuickAppPkg = isQuickAppPkg;
function traverseObjectNode(node, buildAdapter, parentKey) {
    if (node.type === 'ClassProperty' || node.type === 'ObjectProperty') {
        const properties = node.value.properties;
        const obj = {};
        properties.forEach(p => {
            let key = t.isIdentifier(p.key) ? p.key.name : p.key.value;
            if (runner_utils_1.CONFIG_MAP[buildAdapter][key] === false) {
                return;
            }
            if (parentKey !== 'usingComponents' && runner_utils_1.CONFIG_MAP[buildAdapter][key]) {
                key = runner_utils_1.CONFIG_MAP[buildAdapter][key];
            }
            obj[key] = traverseObjectNode(p.value, buildAdapter, key);
        });
        return obj;
    }
    if (node.type === 'ObjectExpression') {
        const properties = node.properties;
        const obj = {};
        properties.forEach(p => {
            let key = t.isIdentifier(p.key) ? p.key.name : p.key.value;
            if (runner_utils_1.CONFIG_MAP[buildAdapter][key] === false) {
                return;
            }
            if (parentKey !== 'usingComponents' && runner_utils_1.CONFIG_MAP[buildAdapter][key]) {
                key = runner_utils_1.CONFIG_MAP[buildAdapter][key];
            }
            obj[key] = traverseObjectNode(p.value, buildAdapter, key);
        });
        return obj;
    }
    if (node.type === 'ArrayExpression') {
        return node.elements.map(item => traverseObjectNode(item, buildAdapter));
    }
    if (node.type === 'NullLiteral') {
        return null;
    }
    return node.value;
}
exports.traverseObjectNode = traverseObjectNode;
function buildUsingComponents(filePath, sourceDir, pathAlias, components, isComponent) {
    const usingComponents = Object.create(null);
    for (const component of components) {
        let componentPath = component.path;
        if (runner_utils_1.isAliasPath(componentPath, pathAlias)) {
            componentPath = runner_utils_1.replaceAliasPath(filePath, componentPath, pathAlias);
        }
        componentPath = runner_utils_1.resolveMainFilePath(path.resolve(filePath, '..', componentPath));
        if (fs.existsSync(componentPath)) {
            if (runner_utils_1.NODE_MODULES_REG.test(componentPath) && !runner_utils_1.NODE_MODULES_REG.test(filePath)) {
                componentPath = componentPath.replace(runner_utils_1.NODE_MODULES_REG, path.join(sourceDir, 'npm'));
            }
            componentPath = runner_utils_1.promoteRelativePath(path.relative(filePath, componentPath));
        }
        else {
            componentPath = component.path;
        }
        if (component.name) {
            usingComponents[component.name] = componentPath.replace(path.extname(componentPath), '');
        }
    }
    return Object.assign({}, isComponent ? { component: true } : { usingComponents: {} }, components.length ? {
        usingComponents
    } : {});
}
exports.buildUsingComponents = buildUsingComponents;
const npmCached = {};
function resolveNpmSync(pkgName, root) {
    try {
        if (!npmCached[pkgName]) {
            return resolvePath.sync(pkgName, { basedir: root });
        }
        return npmCached[pkgName];
    }
    catch (err) {
        if (err.code === 'MODULE_NOT_FOUND') {
            throw new Error(`包 ${pkgName} 未安装`);
        }
        return null;
    }
}
exports.resolveNpmSync = resolveNpmSync;
