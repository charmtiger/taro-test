"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs-extra");
const SingleEntryDependency = require("webpack/lib/dependencies/SingleEntryDependency");
const FunctionModulePlugin = require("webpack/lib/FunctionModulePlugin");
const JsonpTemplatePlugin = require("webpack/lib/web/JsonpTemplatePlugin");
const NodeSourcePlugin = require("webpack/lib/node/NodeSourcePlugin");
const LoaderTargetPlugin = require("webpack/lib/LoaderTargetPlugin");
const runner_utils_1 = require("@tarojs/runner-utils");
const tapable_1 = require("tapable");
const TaroSingleEntryDependency_1 = require("../dependencies/TaroSingleEntryDependency");
const template_1 = require("../template");
const TaroNormalModulesPlugin_1 = require("./TaroNormalModulesPlugin");
const TaroLoadChunksPlugin_1 = require("./TaroLoadChunksPlugin");
const adapters_1 = require("../template/adapters");
const component_1 = require("../template/component");
const prerender_1 = require("../prerender/prerender");
const PLUGIN_NAME = 'TaroMiniPlugin';
exports.createTarget = function createTarget(_) {
    return (compiler) => {
        const { options } = compiler;
        new JsonpTemplatePlugin().apply(compiler);
        new FunctionModulePlugin(options.output).apply(compiler);
        new NodeSourcePlugin(options.node).apply(compiler);
        new LoaderTargetPlugin('node').apply(compiler);
    };
};
exports.Targets = {
    ["weapp" /* WEAPP */]: exports.createTarget("weapp" /* WEAPP */),
    ["alipay" /* ALIPAY */]: exports.createTarget("alipay" /* ALIPAY */),
    ["swan" /* SWAN */]: exports.createTarget("swan" /* SWAN */),
    ["tt" /* TT */]: exports.createTarget("tt" /* TT */),
    ["qq" /* QQ */]: exports.createTarget("qq" /* QQ */),
    ["jd" /* JD */]: exports.createTarget("jd" /* JD */),
    ["quickapp" /* QUICKAPP */]: exports.createTarget("quickapp" /* QUICKAPP */)
};
function isLoaderExist(loaders, loaderName) {
    return loaders.some(item => item.loader === loaderName);
}
class TaroMiniPlugin {
    constructor(options = {}) {
        this.tryAsync = fn => (arg, callback) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield fn(arg);
                callback();
            }
            catch (err) {
                callback(err);
            }
        });
        this.options = Object.assign({
            buildAdapter: "weapp" /* WEAPP */,
            sourceDir: '',
            framework: 'nerv',
            commonChunks: ['runtime', 'vendors'],
            baseLevel: 16
        }, options);
        adapters_1.setAdapter(this.options.buildAdapter);
        this.isWatch = false;
        this.pages = new Set();
        this.components = new Set();
        this.filesConfig = {};
        this.tabBarIcons = new Set();
        this.dependencies = new Map();
    }
    apply(compiler) {
        this.context = compiler.context;
        this.appEntry = this.getAppEntry(compiler);
        compiler.hooks.getPages = new tapable_1.SyncHook(['pages']);
        compiler.hooks.run.tapAsync(PLUGIN_NAME, this.tryAsync((compiler) => __awaiter(this, void 0, void 0, function* () {
            yield this.run(compiler);
        })));
        compiler.hooks.watchRun.tapAsync(PLUGIN_NAME, this.tryAsync((compiler) => __awaiter(this, void 0, void 0, function* () {
            const changedFiles = this.getChangedFiles(compiler);
            if (changedFiles.length) {
                this.isWatch = true;
            }
            yield this.run(compiler);
        })));
        compiler.hooks.make.tapAsync(PLUGIN_NAME, this.tryAsync((compilation) => __awaiter(this, void 0, void 0, function* () {
            const dependencies = this.dependencies;
            const promises = [];
            dependencies.forEach(dep => {
                promises.push(new Promise((resolve, reject) => {
                    compilation.addEntry(this.options.sourceDir, dep, dep.name, err => err ? reject(err) : resolve());
                }));
            });
            yield Promise.all(promises);
        })));
        compiler.hooks.emit.tapAsync(PLUGIN_NAME, this.tryAsync((compilation) => __awaiter(this, void 0, void 0, function* () {
            yield this.generateMiniFiles(compilation);
        })));
        compiler.hooks.afterEmit.tapAsync(PLUGIN_NAME, this.tryAsync((compilation) => __awaiter(this, void 0, void 0, function* () {
            yield this.addTarBarFilesToDependencies(compilation);
        })));
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, { normalModuleFactory }) => {
            compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
            compilation.dependencyFactories.set(TaroSingleEntryDependency_1.default, normalModuleFactory);
            compilation.hooks.normalModuleLoader.tap(PLUGIN_NAME, (loaderContext, module) => {
                const { framework } = this.options;
                if (module.miniType === runner_utils_1.META_TYPE.ENTRY) {
                    const loaderName = '@tarojs/taro-loader';
                    if (!isLoaderExist(module.loaders, loaderName)) {
                        module.loaders.unshift({
                            loader: loaderName,
                            options: {
                                framework,
                                prerender: this.prerenderPages.size > 0
                            }
                        });
                    }
                }
                else if (module.miniType === runner_utils_1.META_TYPE.PAGE) {
                    const loaderName = '@tarojs/taro-loader/lib/page';
                    if (!isLoaderExist(module.loaders, loaderName)) {
                        module.loaders.unshift({
                            loader: loaderName,
                            options: {
                                framework,
                                name: module.name,
                                prerender: this.prerenderPages.has(module.name)
                            }
                        });
                    }
                }
                else if (module.miniType === runner_utils_1.META_TYPE.COMPONENT) {
                    const loaderName = '@tarojs/taro-loader/lib/component';
                    if (!isLoaderExist(module.loaders, loaderName)) {
                        module.loaders.unshift({
                            loader: loaderName,
                            options: {
                                framework,
                                name: module.name,
                                prerender: this.prerenderPages.has(module.name)
                            }
                        });
                    }
                }
            });
            compilation.hooks.afterOptimizeAssets.tap(PLUGIN_NAME, (assets) => {
                Object.keys(assets).forEach(assetPath => {
                    const styleExt = runner_utils_1.MINI_APP_FILES[this.options.buildAdapter].STYLE;
                    const templateExt = runner_utils_1.MINI_APP_FILES[this.options.buildAdapter].TEMPL;
                    if (new RegExp(`${styleExt}.js$`).test(assetPath)) {
                        delete assets[assetPath];
                    }
                    else if (new RegExp(`${styleExt}${styleExt}$`).test(assetPath)) {
                        const assetObj = assets[assetPath];
                        const newAssetPath = assetPath.replace(styleExt, '');
                        assets[newAssetPath] = assetObj;
                        delete assets[assetPath];
                    }
                    else if (new RegExp(`${templateExt}.js$`).test(assetPath)) {
                        delete assets[assetPath];
                    }
                });
            });
        });
        new TaroNormalModulesPlugin_1.default().apply(compiler);
        new TaroLoadChunksPlugin_1.default({
            commonChunks: this.options.commonChunks,
            buildAdapter: this.options.buildAdapter,
            framework: this.options.framework,
            isBuildPlugin: false,
            addChunkPages: this.options.addChunkPages
        }).apply(compiler);
    }
    getAppEntry(compiler) {
        const originalEntry = compiler.options.entry;
        compiler.options.entry = {};
        return path.resolve(this.context, originalEntry.app[0]);
    }
    getAppConfig() {
        const appConfigPath = this.getConfigFilePath(this.appEntry);
        const appConfig = runner_utils_1.readConfig(appConfigPath);
        const appConfigName = path.basename(appConfigPath).replace(path.extname(appConfigPath), '');
        this.filesConfig[appConfigName] = {
            content: appConfig,
            path: appConfigPath
        };
        if (runner_utils_1.isEmptyObject(appConfig)) {
            throw new Error('缺少 app 全局配置，请检查！');
        }
        return appConfig;
    }
    getPagesConfig() {
        this.pages.forEach(page => {
            if (!this.isWatch) {
                runner_utils_1.printLog("compile" /* COMPILE */, '发现页面', this.getShowPath(page.path));
            }
            this.compileFile(page);
        });
    }
    replaceExt(file, ext) {
        return path.join(path.dirname(file), path.basename(file, path.extname(file)) + `${ext}`);
    }
    compileFile(file) {
        const filePath = file.path;
        const fileConfigPath = file.isNative ? this.replaceExt(filePath, '.json') : this.getConfigFilePath(filePath);
        const fileConfig = runner_utils_1.readConfig(fileConfigPath);
        const usingComponents = fileConfig.usingComponents;
        this.filesConfig[this.getConfigFilePath(file.name)] = {
            content: fileConfig,
            path: fileConfigPath
        };
        if (usingComponents) {
            const componentNames = Object.keys(usingComponents);
            const depComponents = [];
            for (const compName of componentNames) {
                depComponents.push({
                    name: compName,
                    path: usingComponents[compName]
                });
                if (!component_1.componentConfig.thirdPartyComponents.has(compName)) {
                    component_1.componentConfig.thirdPartyComponents.set(compName, new Set());
                }
            }
            depComponents.forEach(item => {
                const componentPath = runner_utils_1.resolveMainFilePath(path.resolve(path.dirname(file.path), item.path));
                if (fs.existsSync(componentPath) && !Array.from(this.components).some(item => item.path === componentPath)) {
                    const componentName = this.getComponentName(componentPath);
                    const componentTempPath = this.getTemplatePath(componentPath);
                    const isNative = this.isNativePageORComponent(componentTempPath);
                    const componentObj = {
                        name: componentName,
                        path: componentPath,
                        isNative,
                        stylePath: isNative ? this.getStylePath(componentPath) : null,
                        templatePath: isNative ? this.getTemplatePath(componentPath) : null
                    };
                    this.components.add(componentObj);
                    this.compileFile(componentObj);
                }
            });
        }
    }
    getPages(compiler) {
        if (runner_utils_1.isEmptyObject(this.appConfig)) {
            throw new Error('缺少 app 全局配置，请检查！');
        }
        const appPages = this.appConfig.pages;
        if (!appPages || !appPages.length) {
            throw new Error('全局配置缺少 pages 字段，请检查！');
        }
        if (!this.isWatch) {
            runner_utils_1.printLog("compile" /* COMPILE */, '发现入口', this.getShowPath(this.appEntry));
        }
        const { framework, prerender } = this.options;
        this.prerenderPages = new Set(prerender_1.validatePrerenderPages(appPages, prerender).map(p => p.path));
        this.getSubPackages(this.appConfig);
        this.getTabBarFiles(this.appConfig);
        this.pages = new Set([
            ...this.pages,
            ...appPages.map(item => {
                const pagePath = runner_utils_1.resolveMainFilePath(path.join(this.options.sourceDir, item), framework === runner_utils_1.FRAMEWORK_MAP.VUE ? runner_utils_1.VUE_EXT : runner_utils_1.SCRIPT_EXT);
                const pageTemplatePath = this.getTemplatePath(pagePath);
                const isNative = this.isNativePageORComponent(pageTemplatePath);
                return {
                    name: item,
                    path: pagePath,
                    isNative,
                    stylePath: isNative ? this.getStylePath(pagePath) : null,
                    templatePath: isNative ? this.getTemplatePath(pagePath) : null
                };
            })
        ]);
        compiler.hooks.getPages.call(this.pages);
    }
    getSubPackages(appConfig) {
        const subPackages = appConfig.subPackages || appConfig.subpackages;
        const { framework } = this.options;
        if (subPackages && subPackages.length) {
            subPackages.forEach(item => {
                if (item.pages && item.pages.length) {
                    const root = item.root;
                    item.pages.forEach(page => {
                        let pageItem = `${root}/${page}`;
                        pageItem = pageItem.replace(/\/{2,}/g, '/');
                        let hasPageIn = false;
                        this.pages.forEach(({ name }) => {
                            if (name === pageItem) {
                                hasPageIn = true;
                            }
                        });
                        if (!hasPageIn) {
                            const pagePath = runner_utils_1.resolveMainFilePath(path.join(this.options.sourceDir, pageItem), framework === runner_utils_1.FRAMEWORK_MAP.VUE ? runner_utils_1.VUE_EXT : runner_utils_1.SCRIPT_EXT);
                            const templatePath = this.getTemplatePath(pagePath);
                            const isNative = this.isNativePageORComponent(templatePath);
                            this.pages.add({
                                name: pageItem,
                                path: pagePath,
                                isNative,
                                stylePath: isNative ? this.getStylePath(pagePath) : null,
                                templatePath: isNative ? this.getTemplatePath(pagePath) : null
                            });
                        }
                    });
                }
            });
        }
    }
    getConfigFiles(compiler) {
        const filesConfig = this.filesConfig;
        Object.keys(filesConfig).forEach(item => {
            if (fs.existsSync(filesConfig[item].path)) {
                this.addEntry(filesConfig[item].path, item, runner_utils_1.META_TYPE.CONFIG);
            }
        });
        compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
            compilation.hooks.beforeChunkAssets.tap(PLUGIN_NAME, () => {
                Object.keys(filesConfig).forEach(item => {
                    const assetsChunkIndex = compilation.chunks.findIndex(({ name }) => name === item);
                    if (assetsChunkIndex > -1) {
                        compilation.chunks.splice(assetsChunkIndex, 1);
                    }
                });
            });
        });
    }
    getTabBarFiles(appConfig) {
        const tabBar = appConfig.tabBar;
        const { buildAdapter, sourceDir } = this.options;
        if (tabBar && typeof tabBar === 'object' && !runner_utils_1.isEmptyObject(tabBar)) {
            const { list: listConfig, iconPath: pathConfig, selectedIconPath: selectedPathConfig } = runner_utils_1.CONFIG_MAP[buildAdapter];
            const list = tabBar[listConfig] || [];
            list.forEach(item => {
                item[pathConfig] && this.tabBarIcons.add(item[pathConfig]);
                item[selectedPathConfig] && this.tabBarIcons.add(item[selectedPathConfig]);
            });
            if (tabBar.custom) {
                const customTabBarPath = path.join(sourceDir, 'custom-tab-bar');
                const customTabBarComponentPath = runner_utils_1.resolveMainFilePath(customTabBarPath);
                if (fs.existsSync(customTabBarComponentPath)) {
                    const customTabBarComponentTemplPath = this.getTemplatePath(customTabBarComponentPath);
                    const isNative = this.isNativePageORComponent(customTabBarComponentTemplPath);
                    if (!this.isWatch) {
                        runner_utils_1.printLog("compile" /* COMPILE */, '自定义 tabBar', this.getShowPath(customTabBarComponentPath));
                    }
                    const componentObj = {
                        name: 'custom-tab-bar/index',
                        path: customTabBarComponentPath,
                        isNative,
                        stylePath: isNative ? this.getStylePath(customTabBarComponentPath) : null,
                        templatePath: isNative ? this.getTemplatePath(customTabBarComponentPath) : null
                    };
                    this.compileFile(componentObj);
                    this.components.add(componentObj);
                }
            }
        }
    }
    generateTabBarFiles(compilation) {
        this.tabBarIcons.forEach(icon => {
            const iconPath = path.resolve(this.options.sourceDir, icon);
            if (fs.existsSync(iconPath)) {
                const iconStat = fs.statSync(iconPath);
                const iconSource = fs.readFileSync(iconPath);
                compilation.assets[icon] = {
                    size: () => iconStat.size,
                    source: () => iconSource
                };
            }
        });
    }
    addTarBarFilesToDependencies(compilation) {
        const { fileDependencies } = compilation;
        this.tabBarIcons.forEach(icon => {
            if (!fileDependencies.has(icon)) {
                fileDependencies.add(icon);
            }
        });
    }
    addEntry(entryPath, entryName, entryType) {
        let dep;
        if (this.dependencies.has(entryPath)) {
            dep = this.dependencies.get(entryPath);
            dep.name = entryName;
            dep.loc = { name: entryName };
            dep.entryPath = entryPath;
            dep.entryType = entryType;
        }
        else {
            dep = new TaroSingleEntryDependency_1.default(entryPath, entryName, { name: entryName }, entryType);
        }
        this.dependencies.set(entryPath, dep);
    }
    addEntries() {
        this.addEntry(this.appEntry, 'app', runner_utils_1.META_TYPE.ENTRY);
        this.addEntry(path.resolve(__dirname, '..', 'template/comp'), 'comp', runner_utils_1.META_TYPE.STATIC);
        this.pages.forEach(item => {
            if (item.isNative) {
                this.addEntry(item.path, item.name, runner_utils_1.META_TYPE.NORMAL);
                if (item.stylePath && fs.existsSync(item.stylePath)) {
                    this.addEntry(item.stylePath, this.getStylePath(item.name), runner_utils_1.META_TYPE.NORMAL);
                }
                if (item.templatePath && fs.existsSync(item.templatePath)) {
                    this.addEntry(item.templatePath, this.getTemplatePath(item.name), runner_utils_1.META_TYPE.NORMAL);
                }
            }
            else {
                this.addEntry(item.path, item.name, runner_utils_1.META_TYPE.PAGE);
            }
        });
        this.components.forEach(item => {
            if (item.isNative) {
                this.addEntry(item.path, item.name, runner_utils_1.META_TYPE.NORMAL);
                if (item.stylePath && fs.existsSync(item.stylePath)) {
                    this.addEntry(item.stylePath, this.getStylePath(item.name), runner_utils_1.META_TYPE.NORMAL);
                }
                if (item.templatePath && fs.existsSync(item.templatePath)) {
                    this.addEntry(item.templatePath, this.getTemplatePath(item.name), runner_utils_1.META_TYPE.NORMAL);
                }
            }
            else {
                this.addEntry(item.path, item.name, runner_utils_1.META_TYPE.COMPONENT);
            }
        });
    }
    generateConfigFile(compilation, filePath, config) {
        const fileConfigName = this.getConfigPath(this.getComponentName(filePath));
        const fileConfigStr = JSON.stringify(config);
        compilation.assets[fileConfigName] = {
            size: () => fileConfigStr.length,
            source: () => fileConfigStr
        };
    }
    generateTemplateFile(compilation, filePath, templateFn, ...options) {
        const templStr = templateFn(...options);
        const fileTemplName = this.getTemplatePath(this.getComponentName(filePath));
        compilation.assets[fileTemplName] = {
            size: () => templStr.length,
            source: () => templStr
        };
    }
    generateXSFile(compilation) {
        const ext = runner_utils_1.MINI_APP_FILES[this.options.buildAdapter].XS;
        if (ext == null) {
            return;
        }
        const xs = template_1.buildXScript();
        const filePath = this.getTargetFilePath('utils', ext);
        compilation.assets[filePath] = {
            size: () => xs.length,
            source: () => xs
        };
    }
    get supportRecursive() {
        return this.options.buildAdapter !== "weapp" /* WEAPP */ && this.options.buildAdapter !== "qq" /* QQ */;
    }
    generateMiniFiles(compilation) {
        const baseTemplateName = 'base';
        const baseCompName = 'comp';
        const { baseLevel } = this.options;
        this.generateConfigFile(compilation, this.appEntry, this.appConfig);
        this.generateConfigFile(compilation, baseCompName, {
            components: true,
            usingComponents: {
                [baseCompName]: `./${baseCompName}`
            }
        });
        this.generateTemplateFile(compilation, baseTemplateName, template_1.buildBaseTemplate, baseLevel, this.supportRecursive);
        if (!this.supportRecursive) {
            this.generateTemplateFile(compilation, baseCompName, template_1.buildBaseComponentTemplate);
        }
        this.generateXSFile(compilation);
        this.components.forEach(component => {
            const importBaseTemplatePath = runner_utils_1.promoteRelativePath(path.relative(component.path, path.join(this.options.sourceDir, this.getTemplatePath(baseTemplateName))));
            const config = this.filesConfig[this.getConfigFilePath(component.name)];
            if (config) {
                this.generateConfigFile(compilation, component.path, config.content);
            }
            if (!component.isNative) {
                this.generateTemplateFile(compilation, component.path, template_1.buildPageTemplate, importBaseTemplatePath);
            }
        });
        this.pages.forEach(page => {
            const importBaseTemplatePath = runner_utils_1.promoteRelativePath(path.relative(page.path, path.join(this.options.sourceDir, this.getTemplatePath(baseTemplateName))));
            const config = this.filesConfig[this.getConfigFilePath(page.name)];
            if (config) {
                if (!this.supportRecursive) {
                    const importBaseCompPath = runner_utils_1.promoteRelativePath(path.relative(page.path, path.join(this.options.sourceDir, this.getTargetFilePath(baseCompName, ''))));
                    config.content.usingComponents = Object.assign({ [baseCompName]: importBaseCompPath }, config.content.usingComponents);
                }
                this.generateConfigFile(compilation, page.path, config.content);
            }
            if (!page.isNative) {
                this.generateTemplateFile(compilation, page.path, template_1.buildPageTemplate, importBaseTemplatePath);
            }
        });
        this.generateTabBarFiles(compilation);
    }
    run(compiler) {
        this.appConfig = this.getAppConfig();
        this.getPages(compiler);
        this.getPagesConfig();
        this.getConfigFiles(compiler);
        this.addEntries();
    }
    getComponentName(componentPath) {
        let componentName;
        if (runner_utils_1.NODE_MODULES_REG.test(componentPath)) {
            componentName = componentPath.replace(this.context, '').replace(/\\/g, '/').replace(path.extname(componentPath), '');
            componentName = componentName.replace(/node_modules/gi, 'npm');
        }
        else {
            componentName = componentPath.replace(this.options.sourceDir, '').replace(/\\/g, '/').replace(path.extname(componentPath), '');
        }
        return componentName.replace(/^(\/|\\)/, '');
    }
    getChangedFiles(compiler) {
        const { watchFileSystem } = compiler;
        const watcher = watchFileSystem.watcher || watchFileSystem.wfs.watcher;
        return Object.keys(watcher.mtimes);
    }
    isNativePageORComponent(templatePath) {
        return fs.existsSync(templatePath);
    }
    getShowPath(filePath) {
        return filePath.replace(this.context, '').replace(/\\/g, '/').replace(/^\//, '');
    }
    getConfigFilePath(filePath) {
        return runner_utils_1.resolveMainFilePath(`${filePath.replace(path.extname(filePath), '')}.config`);
    }
    getTemplatePath(filePath) {
        return this.getTargetFilePath(filePath, runner_utils_1.MINI_APP_FILES[this.options.buildAdapter].TEMPL);
    }
    getStylePath(filePath) {
        return this.getTargetFilePath(filePath, runner_utils_1.MINI_APP_FILES[this.options.buildAdapter].STYLE);
    }
    getConfigPath(filePath) {
        return this.getTargetFilePath(filePath, runner_utils_1.MINI_APP_FILES[this.options.buildAdapter].CONFIG);
    }
    getTargetFilePath(filePath, targetExtname) {
        const extname = path.extname(filePath);
        if (extname) {
            return filePath.replace(extname, targetExtname);
        }
        return filePath + targetExtname;
    }
}
exports.default = TaroMiniPlugin;
