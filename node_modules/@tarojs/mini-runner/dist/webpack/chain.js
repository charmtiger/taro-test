"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const CopyWebpackPlugin = require("copy-webpack-plugin");
const csso_webpack_plugin_1 = require("csso-webpack-plugin");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const sass = require("node-sass");
const lodash_1 = require("lodash");
const fp_1 = require("lodash/fp");
const TerserPlugin = require("terser-webpack-plugin");
const webpack = require("webpack");
const chalk_1 = require("chalk");
const runner_utils_1 = require("@tarojs/runner-utils");
const postcss_conf_1 = require("./postcss.conf");
const MiniPlugin_1 = require("../plugins/MiniPlugin");
const shared_1 = require("@tarojs/shared");
const component_1 = require("../template/component");
const terserOptions_1 = require("../config/terserOptions");
const globalObjectMap = {
    ["weapp" /* WEAPP */]: 'wx',
    ["alipay" /* ALIPAY */]: 'my',
    ["swan" /* SWAN */]: 'swan',
    ["qq" /* QQ */]: 'qq',
    ["tt" /* TT */]: 'tt',
    ["jd" /* JD */]: 'jd',
    ["quickapp" /* QUICKAPP */]: 'global'
};
const defaultCSSCompressOption = {
    mergeRules: false,
    mergeIdents: false,
    reduceIdents: false,
    discardUnused: false,
    minifySelectors: false
};
const defaultMediaUrlLoaderOption = {
    limit: 10240
};
const defaultFontUrlLoaderOption = {
    limit: 10240
};
const defaultImageUrlLoaderOption = {
    limit: 2046
};
const defaultCssModuleOption = {
    enable: false,
    config: {
        namingPattern: 'global',
        generateScopedName: '[name]__[local]___[hash:base64:5]'
    }
};
const defaultUrlOption = {
    enable: true,
    config: {
        limit: 10240 // limit 10k base on document
    }
};
const getLoader = (loaderName, options) => {
    return {
        loader: require.resolve(loaderName),
        options: options || {}
    };
};
const listify = listOrItem => {
    if (Array.isArray(listOrItem)) {
        return listOrItem;
    }
    return [listOrItem];
};
const getPlugin = (plugin, args) => {
    return {
        plugin,
        args
    };
};
exports.mergeOption = ([...options]) => {
    return runner_utils_1.recursiveMerge({}, ...options);
};
const styleModuleReg = /(.*\.module).*\.(css|s[ac]ss|less|styl)\b/;
const styleGlobalReg = /(.*\.global).*\.(css|s[ac]ss|less|styl)\b/;
exports.processEnvOption = lodash_1.partial(fp_1.mapKeys, (key) => `process.env.${key}`);
exports.getCssLoader = fp_1.pipe(exports.mergeOption, lodash_1.partial(getLoader, 'css-loader'));
exports.getPostcssLoader = fp_1.pipe(exports.mergeOption, lodash_1.partial(getLoader, 'postcss-loader'));
exports.getSassLoader = fp_1.pipe(exports.mergeOption, lodash_1.partial(getLoader, 'sass-loader'));
exports.getLessLoader = fp_1.pipe(exports.mergeOption, lodash_1.partial(getLoader, 'less-loader'));
exports.getStylusLoader = fp_1.pipe(exports.mergeOption, lodash_1.partial(getLoader, 'stylus-loader'));
exports.getUrlLoader = fp_1.pipe(exports.mergeOption, lodash_1.partial(getLoader, 'url-loader'));
exports.getFileLoader = fp_1.pipe(exports.mergeOption, lodash_1.partial(getLoader, 'file-loader'));
exports.getBabelLoader = fp_1.pipe(exports.mergeOption, lodash_1.partial(getLoader, 'babel-loader'));
exports.getVueLoader = fp_1.pipe(exports.mergeOption, lodash_1.partial(getLoader, 'vue-loader'));
exports.getMiniTemplateLoader = fp_1.pipe(exports.mergeOption, lodash_1.partial(getLoader, path.resolve(__dirname, '../loaders/miniTemplateLoader')));
const getExtractCssLoader = () => {
    return {
        loader: MiniCssExtractPlugin.loader
    };
};
const getQuickappStyleLoader = () => {
    return {
        loader: require.resolve(path.resolve(__dirname, '../loaders/quickappStyleLoader'))
    };
};
exports.getMiniCssExtractPlugin = fp_1.pipe(exports.mergeOption, listify, lodash_1.partial(getPlugin, MiniCssExtractPlugin));
exports.getDefinePlugin = fp_1.pipe(exports.mergeOption, listify, lodash_1.partial(getPlugin, webpack.DefinePlugin));
exports.getTerserPlugin = ([enableSourceMap, terserOptions]) => {
    return new TerserPlugin({
        cache: true,
        parallel: true,
        sourceMap: enableSourceMap,
        terserOptions: runner_utils_1.recursiveMerge({}, terserOptions_1.default, terserOptions)
    });
};
exports.getCssoWebpackPlugin = ([cssoOption]) => {
    return fp_1.pipe(listify, lodash_1.partial(getPlugin, csso_webpack_plugin_1.default))([exports.mergeOption([defaultCSSCompressOption, cssoOption]), runner_utils_1.REG_STYLE]);
};
exports.getCopyWebpackPlugin = ({ copy, appPath }) => {
    const args = [
        copy.patterns.map(({ from, to }) => {
            return {
                from,
                to: path.resolve(appPath, to),
                context: appPath
            };
        }),
        copy.options
    ];
    return lodash_1.partial(getPlugin, CopyWebpackPlugin)(args);
};
exports.getMiniPlugin = args => {
    return lodash_1.partial(getPlugin, MiniPlugin_1.default)([args]);
};
exports.getProviderPlugin = args => {
    return lodash_1.partial(getPlugin, webpack.ProvidePlugin)([args]);
};
exports.getModule = (appPath, { sourceDir, designWidth, deviceRatio, buildAdapter, 
// constantsReplaceList,
enableSourceMap, cssLoaderOption, lessLoaderOption, sassLoaderOption, stylusLoaderOption, fontUrlLoaderOption, imageUrlLoaderOption, mediaUrlLoaderOption, postcss
// babel
 }) => {
    const isQuickapp = buildAdapter === "quickapp" /* QUICKAPP */;
    const postcssOption = postcss || {};
    const cssModuleOptions = runner_utils_1.recursiveMerge({}, defaultCssModuleOption, postcssOption.cssModules);
    const { namingPattern, generateScopedName } = cssModuleOptions.config;
    const cssOptions = [
        {
            importLoaders: 1,
            sourceMap: enableSourceMap,
            modules: false
        },
        cssLoaderOption
    ];
    const cssOptionsWithModule = [
        Object.assign({
            importLoaders: 1,
            sourceMap: enableSourceMap,
            modules: {
                mode: namingPattern === 'module' ? 'local' : 'global'
            }
        }, {
            modules: typeof generateScopedName === 'function'
                ? { getLocalIdent: (context, _, localName) => generateScopedName(localName, context.resourcePath) }
                : { localIdentName: generateScopedName }
        }),
        cssLoaderOption
    ];
    const extractCssLoader = getExtractCssLoader();
    const quickappStyleLoader = getQuickappStyleLoader();
    const miniTemplateLoader = exports.getMiniTemplateLoader([{
            buildAdapter
        }]);
    const cssLoader = exports.getCssLoader(cssOptions);
    const sassLoader = exports.getSassLoader([{
            sourceMap: true,
            implementation: sass
        }, sassLoaderOption]);
    const postcssLoader = exports.getPostcssLoader([
        { sourceMap: enableSourceMap },
        {
            ident: 'postcss',
            plugins: postcss_conf_1.getPostcssPlugins(appPath, {
                isQuickapp,
                designWidth,
                deviceRatio,
                postcssOption
            })
        }
    ]);
    const lessLoader = exports.getLessLoader([{ sourceMap: enableSourceMap }, lessLoaderOption]);
    const stylusLoader = exports.getStylusLoader([{ sourceMap: enableSourceMap }, stylusLoaderOption]);
    const cssLoaders = [{
            use: isQuickapp ? [
                extractCssLoader,
                quickappStyleLoader,
                cssLoader,
                postcssLoader
            ] : [
                extractCssLoader,
                cssLoader,
                postcssLoader
            ]
        }];
    if (cssModuleOptions.enable) {
        const cssLoaderWithModule = exports.getCssLoader(cssOptionsWithModule);
        let cssModuleCondition;
        if (cssModuleOptions.config.namingPattern === 'module') {
            /* 不排除 node_modules 内的样式 */
            cssModuleCondition = styleModuleReg;
        }
        else {
            cssModuleCondition = {
                and: [
                    { exclude: styleGlobalReg },
                    { exclude: [runner_utils_1.isNodeModule] }
                ]
            };
        }
        cssLoaders.unshift({
            include: [cssModuleCondition],
            use: [
                extractCssLoader,
                cssLoaderWithModule,
                postcssLoader
            ]
        });
    }
    const urlOptions = runner_utils_1.recursiveMerge({}, defaultUrlOption, postcssOption.url);
    let postcssUrlOption;
    if (urlOptions.enable) {
        postcssUrlOption = urlOptions.config;
    }
    function addCssLoader(cssLoaders, loader) {
        const cssLoadersCopy = lodash_1.cloneDeep(cssLoaders);
        cssLoadersCopy.forEach(item => {
            item.use && item.use.push(loader);
        });
        return cssLoadersCopy;
    }
    const rule = {
        sass: {
            test: runner_utils_1.REG_SASS,
            oneOf: addCssLoader(cssLoaders, sassLoader)
        },
        less: {
            test: runner_utils_1.REG_LESS,
            oneOf: addCssLoader(cssLoaders, lessLoader)
        },
        stylus: {
            test: runner_utils_1.REG_STYLUS,
            oneOf: addCssLoader(cssLoaders, stylusLoader)
        },
        nomorlCss: {
            test: runner_utils_1.REG_CSS,
            oneOf: cssLoaders
        },
        vue: {
            test: runner_utils_1.REG_VUE,
            use: {
                vueLoader: exports.getVueLoader([{
                        optimizeSSR: false,
                        transformAssetUrls: {
                            video: ['src', 'poster'],
                            'live-player': 'src',
                            audio: 'src',
                            source: 'src',
                            image: 'src',
                            'cover-image': 'src'
                        },
                        compilerOptions: {
                            modules: [{
                                    preTransformNode(el) {
                                        const nodeName = el.tag;
                                        if (shared_1.capitalize(shared_1.toCamelCase(nodeName)) in shared_1.internalComponents) {
                                            component_1.componentConfig.includes.add(nodeName);
                                        }
                                        const usingComponent = component_1.componentConfig.thirdPartyComponents.get(nodeName);
                                        if (usingComponent != null) {
                                            el.attrsList
                                                .filter(a => !a.dynamic)
                                                .forEach(a => usingComponent.add(a.name.startsWith(':') ? a.name.slice(1) : a.name));
                                        }
                                        return el;
                                    }
                                }]
                        }
                    }])
            }
        },
        script: {
            test: runner_utils_1.REG_SCRIPTS,
            use: {
                babelLoader: exports.getBabelLoader([])
            }
        },
        template: {
            test: runner_utils_1.REG_TEMPLATE,
            use: [exports.getFileLoader([{
                        useRelativePath: true,
                        name: `[path][name]${runner_utils_1.MINI_APP_FILES[buildAdapter].TEMPL}`,
                        context: sourceDir
                    }]), miniTemplateLoader]
        },
        media: {
            test: runner_utils_1.REG_MEDIA,
            use: {
                urlLoader: exports.getUrlLoader([defaultMediaUrlLoaderOption, Object.assign(Object.assign({ name: '[path][name].[ext]', useRelativePath: true, context: sourceDir }, (postcssUrlOption || {})), mediaUrlLoaderOption)])
            }
        },
        font: {
            test: runner_utils_1.REG_FONT,
            use: {
                urlLoader: exports.getUrlLoader([defaultFontUrlLoaderOption, Object.assign(Object.assign({ name: '[path][name].[ext]', useRelativePath: true, context: sourceDir }, (postcssUrlOption || {})), fontUrlLoaderOption)])
            }
        },
        image: {
            test: runner_utils_1.REG_IMAGE,
            use: {
                urlLoader: exports.getUrlLoader([defaultImageUrlLoaderOption, Object.assign(Object.assign({ name: '[path][name].[ext]', useRelativePath: true, context: sourceDir }, (postcssUrlOption || {})), imageUrlLoaderOption)])
            }
        }
    };
    return { rule };
};
exports.getEntry = ({ sourceDir, entry, isBuildPlugin }) => {
    if (!isBuildPlugin) {
        return {
            entry
        };
    }
    const pluginDir = path.join(sourceDir, 'plugin');
    if (!fs.existsSync(pluginDir)) {
        console.log(chalk_1.default.red('插件目录不存在，请检查！'));
        return;
    }
    const pluginConfigPath = path.join(pluginDir, 'plugin.json');
    if (!fs.existsSync(pluginConfigPath)) {
        console.log(chalk_1.default.red('缺少插件配置文件，请检查！'));
        return;
    }
    const pluginConfig = fs.readJSONSync(pluginConfigPath);
    const entryObj = {};
    Object.keys(pluginConfig).forEach(key => {
        if (key === 'main') {
            const filePath = path.join(pluginDir, pluginConfig[key]);
            const fileName = path.basename(filePath).replace(path.extname(filePath), '');
            entryObj[`plugin/${fileName}`] = [runner_utils_1.resolveMainFilePath(filePath.replace(path.extname(filePath), ''))];
        }
        else if (key === 'publicComponents' || key === 'pages') {
            Object.keys(pluginConfig[key]).forEach(subKey => {
                const filePath = path.join(pluginDir, pluginConfig[key][subKey]);
                entryObj[`plugin/${pluginConfig[key][subKey]}`] = [runner_utils_1.resolveMainFilePath(filePath.replace(path.extname(filePath), ''))];
            });
        }
    });
    return {
        entry: entryObj,
        pluginConfig
    };
};
function getOutput(appPath, [{ outputRoot, publicPath, buildAdapter }, customOutput]) {
    return Object.assign({ path: path.join(appPath, outputRoot), publicPath, filename: '[name].js', chunkFilename: '[name].js', globalObject: globalObjectMap[buildAdapter] }, customOutput);
}
exports.getOutput = getOutput;
function getDevtool(enableSourceMap) {
    return enableSourceMap ? 'source-map' : 'none';
}
exports.getDevtool = getDevtool;
