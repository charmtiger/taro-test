"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const shared_1 = require("@tarojs/shared");
const runner_utils_1 = require("@tarojs/runner-utils");
const vm2_1 = require("vm2");
const lodash_1 = require("lodash");
const fs = require("fs");
const path_1 = require("path");
const adapters_1 = require("../template/adapters");
const logHelper_1 = require("../utils/logHelper");
const template_1 = require("../template");
const { JSDOM } = require('jsdom');
const wx = require('miniprogram-simulate/src/api');
const micromatch = require('micromatch');
function validatePrerenderPages(pages, config) {
    let pageConfigs = [];
    if (config == null) {
        return pageConfigs;
    }
    const { include = [], exclude = [], match } = config;
    if (match) {
        pageConfigs = micromatch(pages, match).map((p) => ({ path: p, params: {} }));
    }
    for (const page of pages) {
        for (const i of include) {
            if (shared_1.isString(i) && i === page) {
                pageConfigs.push({
                    path: page,
                    params: {}
                });
            }
            if (shared_1.isObject(i) && i.path === page) {
                pageConfigs.push(Object.assign({
                    params: {}
                }, i));
            }
        }
    }
    pageConfigs = pageConfigs.filter(p => !exclude.includes(p.path));
    return pageConfigs;
}
exports.validatePrerenderPages = validatePrerenderPages;
class Prerender {
    constructor(buildConfig, webpackConfig, stat) {
        this.appLoaded = false;
        this.renderToXML = (data) => {
            var _a;
            const nodeName = data["nn" /* NodeName */];
            if (nodeName === '#text') {
                return data["v" /* Text */];
            }
            // eslint-disable-next-line dot-notation
            if (data['disablePrerender'] || data['disable-prerender']) {
                return '';
            }
            const style = data["st" /* Style */];
            const klass = data["cl" /* Class */];
            const children = (_a = data["cn" /* Childnodes */]) !== null && _a !== void 0 ? _a : [];
            const attrs = lodash_1.omitBy(data, (_, key) => {
                const internal = ["nn" /* NodeName */, "cn" /* Childnodes */, "cl" /* Class */, "st" /* Style */, "v" /* Text */, 'uid'];
                return internal.includes(key) || key.startsWith('data-');
            });
            return `<${nodeName}${style ? ` style="${style}"` : ''}${klass ? ` class="${klass}"` : ''} ${template_1.buildAttribute(attrs, nodeName)}>${children.map(this.renderToXML).join('')}</${nodeName}>`;
        };
        this.buildConfig = buildConfig;
        this.outputPath = webpackConfig.output.path;
        this.globalObject = webpackConfig.output.globalObject;
        this.prerenderConfig = buildConfig.prerender;
        this.stat = stat.toJson();
        this.vm = new vm2_1.NodeVM({
            console: this.prerenderConfig.console ? 'inherit' : 'off',
            require: {
                external: true,
                context: 'sandbox'
            },
            sandbox: this.buildSandbox()
        });
    }
    render() {
        return __awaiter(this, void 0, void 0, function* () {
            const pages = validatePrerenderPages(Object.keys(this.stat.entrypoints), this.prerenderConfig);
            if (!this.prerenderConfig.console && !this.appLoaded) {
                process.on('unhandledRejection', shared_1.noop);
            }
            yield this.writeScript('app');
            if (!this.appLoaded) {
                this.vm.run(`
        const app = require('${this.getRealPath('app')}')
        app.onLaunch()
      `, this.outputPath);
                this.appLoaded = true;
                yield Promise.resolve();
            }
            yield Promise.all(pages.map(p => this.writeScript(p.path)));
            for (const page of pages) {
                try {
                    yield this.writeXML(page);
                    logHelper_1.printPrerenderSuccess(page.path);
                }
                catch (error) {
                    logHelper_1.printPrerenderFail(page.path);
                    console.error(error);
                }
            }
        });
    }
    getRealPath(path, ext = '.js') {
        return path_1.join(this.outputPath, path + ext);
    }
    buildSandbox() {
        const Page = (config) => config;
        const App = (config) => config;
        const dom = new JSDOM();
        const mock = this.prerenderConfig.mock;
        return Object.assign(Object.assign(Object.assign({}, dom), { Page,
            App, [this.globalObject]: wx, getCurrentPages: shared_1.noop, getApp: shared_1.noop, requirePlugin: shared_1.noop, PRERENDER: true }), mock);
    }
    writeXML(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const { path } = config;
            let data = yield this.renderToData(config);
            if (shared_1.isFunction(this.prerenderConfig.transformData)) {
                data = this.prerenderConfig.transformData(data, config);
            }
            let xml = this.renderToXML(data);
            if (shared_1.isFunction(this.prerenderConfig.transformXML)) {
                xml = this.prerenderConfig.transformXML(data, config, xml);
            }
            const templatePath = this.getRealPath(path, runner_utils_1.MINI_APP_FILES[this.buildConfig.buildAdapter].TEMPL);
            const [importTemplate, template] = fs.readFileSync(templatePath, 'utf-8').split('\n');
            let str = `${importTemplate}\n`;
            str += `<block ${adapters_1.Adapter.if}="{{root.uid}}">\n`;
            str += `  ${template}\n`;
            str += '</block>\n';
            str += `<block ${adapters_1.Adapter.else}>\n`;
            str += `${xml}\n`;
            str += '</block>';
            fs.writeFileSync(templatePath, str, 'utf-8');
        });
    }
    writeScript(path) {
        path = this.getRealPath(path);
        return new Promise((resolve) => {
            const s = `
      if (typeof PRERENDER !== 'undefiend') {
        module.exports = global._prerender
      }`;
            fs.appendFile(path, s, 'utf8', () => {
                resolve();
            });
        });
    }
    renderToData({ path, params }) {
        return new Promise((resolve, reject) => {
            const dataReceiver = this.vm.run(`
        const page = require('${this.getRealPath(path)}')
        page.route = '${path}'
        module.exports = function (cb) {
          page.onLoad(${JSON.stringify(params || {})}, cb)
        }
      `, this.outputPath);
            dataReceiver((data) => {
                const domTree = data['root.cn.[0]'] || data['root.cn[0]'];
                if (domTree == null) {
                    reject(new Error('初始化渲染没有任何数据。'));
                }
                resolve(domTree);
            });
        });
    }
}
exports.Prerender = Prerender;
