"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs-extra");
const lodash_1 = require("lodash");
const chalk = require("chalk");
const babel = require("@babel/core");
const constants_1 = require("./constants");
exports.isNodeModule = (filename) => constants_1.NODE_MODULES_REG.test(filename);
function isNpmPkg(name) {
    if (/^(\.|\/)/.test(name)) {
        return false;
    }
    return true;
}
exports.isNpmPkg = isNpmPkg;
function isEmptyObject(obj) {
    if (obj == null) {
        return true;
    }
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}
exports.isEmptyObject = isEmptyObject;
function isAliasPath(name, pathAlias = {}) {
    const prefixs = Object.keys(pathAlias);
    if (prefixs.length === 0) {
        return false;
    }
    return prefixs.includes(name) || (new RegExp(`^(${prefixs.join('|')})/`).test(name));
}
exports.isAliasPath = isAliasPath;
function replaceAliasPath(filePath, name, pathAlias = {}) {
    // 后续的 path.join 在遇到符号链接时将会解析为真实路径，如果
    // 这里的 filePath 没有做同样的处理，可能会导致 import 指向
    // 源代码文件，导致文件被意外修改
    filePath = fs.realpathSync(filePath);
    const prefixs = Object.keys(pathAlias);
    if (prefixs.includes(name)) {
        return promoteRelativePath(path.relative(filePath, fs.realpathSync(resolveMainFilePath(pathAlias[name]))));
    }
    const reg = new RegExp(`^(${prefixs.join('|')})/(.*)`);
    name = name.replace(reg, function (m, $1, $2) {
        return promoteRelativePath(path.relative(filePath, path.join(pathAlias[$1], $2)));
    });
    return name;
}
exports.replaceAliasPath = replaceAliasPath;
function promoteRelativePath(fPath) {
    const fPathArr = fPath.split(path.sep);
    let dotCount = 0;
    fPathArr.forEach(item => {
        if (item.indexOf('..') >= 0) {
            dotCount++;
        }
    });
    if (dotCount === 1) {
        fPathArr.splice(0, 1, '.');
        return fPathArr.join('/');
    }
    if (dotCount > 1) {
        fPathArr.splice(0, 1);
        return fPathArr.join('/');
    }
    return fPath.replace(/\\/g, '/');
}
exports.promoteRelativePath = promoteRelativePath;
function resolveMainFilePath(p, extArrs = constants_1.SCRIPT_EXT) {
    const realPath = p;
    const taroEnv = process.env.TARO_ENV;
    for (let i = 0; i < extArrs.length; i++) {
        const item = extArrs[i];
        if (taroEnv) {
            if (fs.existsSync(`${p}.${taroEnv}${item}`)) {
                return `${p}.${taroEnv}${item}`;
            }
            if (fs.existsSync(`${p}${path.sep}index.${taroEnv}${item}`)) {
                return `${p}${path.sep}index.${taroEnv}${item}`;
            }
            if (fs.existsSync(`${p.replace(/\/index$/, `.${taroEnv}/index`)}${item}`)) {
                return `${p.replace(/\/index$/, `.${taroEnv}/index`)}${item}`;
            }
        }
        if (fs.existsSync(`${p}${item}`)) {
            return `${p}${item}`;
        }
        if (fs.existsSync(`${p}${path.sep}index${item}`)) {
            return `${p}${path.sep}index${item}`;
        }
    }
    return realPath;
}
exports.resolveMainFilePath = resolveMainFilePath;
exports.recursiveMerge = (src, ...args) => {
    return lodash_1.mergeWith(src, ...args, (value, srcValue) => {
        const typeValue = typeof value;
        const typeSrcValue = typeof srcValue;
        if (typeValue !== typeSrcValue)
            return;
        if (Array.isArray(value) && Array.isArray(srcValue)) {
            return value.concat(srcValue);
        }
        if (typeValue === 'object') {
            return exports.recursiveMerge(value, srcValue);
        }
    });
};
function getInstalledNpmPkgPath(pkgName, basedir) {
    const resolvePath = require('resolve');
    try {
        return resolvePath.sync(`${pkgName}/package.json`, { basedir });
    }
    catch (err) {
        return null;
    }
}
exports.getInstalledNpmPkgPath = getInstalledNpmPkgPath;
function printLog(type, tag, filePath) {
    const typeShow = constants_1.processTypeMap[type];
    const tagLen = tag.replace(/[\u0391-\uFFE5]/g, 'aa').length;
    const tagFormatLen = 8;
    if (tagLen < tagFormatLen) {
        const rightPadding = new Array(tagFormatLen - tagLen + 1).join(' ');
        tag += rightPadding;
    }
    const padding = '';
    filePath = filePath || '';
    if (typeof typeShow.color === 'string') {
        console.warn(chalk[typeShow.color](typeShow.name), padding, tag, padding, filePath);
    }
    else {
        console.warn(typeShow.color(typeShow.name), padding, tag, padding, filePath);
    }
}
exports.printLog = printLog;
function removeHeadSlash(str) {
    return str.replace(/^(\/|\\)/, '');
}
exports.removeHeadSlash = removeHeadSlash;
function readConfig(configPath) {
    if (fs.existsSync(configPath)) {
        try {
            delete require.cache[require.resolve(configPath)];
            const config = require(configPath);
            return config;
        }
        catch (error) {
            const res = babel.transformFileSync(configPath, {
                presets: [['@babel/env']],
                plugins: ['@babel/plugin-proposal-class-properties']
            });
            // eslint-disable-next-line no-eval
            return eval(res.code);
        }
    }
    return {};
}
exports.readConfig = readConfig;
